filterCounts <- function(data, mode=c("direct", "trended", "local"), 
	dispersion=0.05, distance="mid", prior=NULL, span=0.3, max.flank=2, min.flank=0)
# Takes a 'data' object generated by squareCounts, and then returns a vector of
# threshold values for each row in the aforementioned 'data' object. Different
# choices of filtering strategy are available.
{
	mode <- match.arg(mode)
	ave.count <- .computeAveCount(data$counts, data$totals, dispersion=dispersion)

	if (mode=="direct") {
		is.inter <- !getDistance(data, get.local=TRUE)
		if (!any(is.inter)) { stop("cannot compute median interchromosomal contact without interchromosomal pairs") }
		threshold <- median(ave.count[is.inter], na.rm=TRUE)
		return(ave.count-threshold)
	} 
	else if (mode=="trended") {
		# Choosing the prior and threshold for interchromosomals rather
		# arbitrarily.  The former is just half of the smallest non-negative distance.
		# The latter is the minimum fit. We can't default to the median of
		# interchromosomals (which would be the equivalent to the loess) as
		# interchromosomals will overrun intrachromosomals just due to numbers.
		dist <- getDistance(data, type=distance)
		is.inter <- is.na(dist)
		if (all(is.inter)) { stop("no intrachromosomal bin pairs with which to fit a trend") }
		if (is.null(prior)) { prior <- min(dist[dist > 0L], na.rm=TRUE)/2 }
		log.dist <- log10(dist + prior)
		fitted <- loessFit(x=log.dist, y=ave.count, span=span)$fitted
		fitted[is.inter] <- min(fitted[!is.inter])
		return(ave.count-fitted)
	} 
	else if (mode=="local") { 
		surrounds <- countNeighbors(data, flank=max.flank)
		new.counts <- surrounds$counts
		new.n <- surrounds$n
		min.flank <- as.integer(min.flank)
		# Options to have a sort of 'cross-hair' method for measuring background.
		if (min.flank) {
			if (min.flank >= max.flank) { stop("minimum flank must be less than the maximum flank") }
			sub.surrounds <- countNeighbors(data, flank=min.flank)
			new.counts <- new.counts - sub.surrounds$counts
			new.n <- new.n - sub.surrounds$n
		}
		near.count <- .computeAveCount(new.counts, data$totals, dispersion=dispersion) - log(new.n)
		return(ave.count-near.count)
	}	
}

.computeAveCount <- function(counts, totals, dispersion=0.05) {
	log.sizes <- log(totals)       
	log.sizes <- log.sizes - mean(log.sizes)        
	mglmOneGroup(counts, offset=log.sizes, dispersion=dispersion)
}
