
R version 3.1.0 (2014-04-10) -- "Spring Dance"
Copyright (C) 2014 The R Foundation for Statistical Computing
Platform: x86_64-unknown-linux-gnu (64-bit)

R is free software and comes with ABSOLUTELY NO WARRANTY.
You are welcome to redistribute it under certain conditions.
Type 'license()' or 'licence()' for distribution details.

  Natural language support but running in an English locale

R is a collaborative project with many contributors.
Type 'contributors()' for more information and
'citation()' on how to cite R or R packages in publications.

Type 'demo()' for some demos, 'help()' for on-line help, or
'help.start()' for an HTML browser interface to help.
Type 'q()' to quit R.

> ####################################################################################################
> # This script tests the pair manipulation functions of savePairs and mergePairs.
> 
> suppressPackageStartupMessages(require(diffHic))
> suppressPackageStartupMessages(require(rhdf5))
> 
> countcomp<-function(n, nfrags, maxc) {
+ 	ai<-as.integer(runif(n, 1, nfrags))
+ 	ti<-as.integer(runif(n, 1, nfrags))
+ 	co<-as.integer(runif(n, 1, maxc))
+ 	out<-data.frame(anchor.id=ai, target.id=ti, count=co)
+ 	out<-out[order(ai, ti),]
+ 
+ 	# Checking counting.
+ 	counted<-diffHic:::.sortedAggregate(out)
+ 	comp<-aggregate(co~ai+ti, data=NULL, FUN=length)
+ 	comp<-comp[order(comp[,1], comp[,2]),]
+ 	stopifnot(identical(counted$count, comp[,3]))
+ 	
+ 	# Checking summation.
+ 	counted<-diffHic:::.sortedAggregate(out, mode="sum")
+ 	comp<-aggregate(co~ai+ti, data=NULL, FUN=sum)
+ 	comp<-comp[order(comp[,1], comp[,2]),]
+ 	stopifnot(identical(counted$count, comp[,3]))
+ 	return(head(counted))
+ }
> 
> set.seed(1452312)
> 
> countcomp(100, 10, 5)
  anchor.id target.id count
1         1         1    13
2         1         2     1
3         1         3     2
4         1         4     1
5         1         8     5
6         1         9     3
> countcomp(100, 10, 15)
  anchor.id target.id count
1         1         1    13
2         1         2     7
3         1         3    13
4         1         5     7
5         1         6     7
6         1         7    15
> countcomp(100, 10, 25)
  anchor.id target.id count
1         1         1    23
2         1         2    22
3         1         3     4
4         1         4     1
5         1         6    16
6         1         7    17
> countcomp(10, 100, 5)
  anchor.id target.id count
1         1        56     1
2         8         2     2
3         9        65     2
4        15        81     1
5        28        35     1
6        37        47     4
> countcomp(10, 100, 15)
  anchor.id target.id count
1         4        38     6
2        32        41     1
3        42        72     3
4        57        52    13
5        58        24     4
6        76        60     1
> countcomp(10, 100, 25)
  anchor.id target.id count
1         5        83    20
2         9        66    20
3        12        36    17
4        13         2     5
5        20        65    19
6        36        47    11
> countcomp(50, 50, 5)
  anchor.id target.id count
1         1        12     4
2         2        36     3
3         3         2     3
4         3        33     1
5         6         1     3
6         8        32     2
> countcomp(50, 50, 15)
  anchor.id target.id count
1         1        33    12
2         1        49     8
3         2        14    12
4         2        18     1
5         2        23    14
6         3        20     9
> countcomp(50, 50, 25)
  anchor.id target.id count
1         1        30     5
2         1        47     4
3         2        36     6
4         3         8    22
5         3        30    21
6         3        33    16
> 
> ####################################################################################################
> # Now, checking the behaviour of savePairs. In particular, looking for correct indexing.
> 
> tmp<-"temp-pairs"
> dir.create(tmp)
> savecomp<-function(n, nfrags, nchrs) {
+ 	# Simulating the dudes (target<=anchor at all times).
+ 	ai<-as.integer(runif(n, 1, nfrags))
+ 	ti<-as.integer(runif(n, 1, nfrags))
+ 	out<-data.frame(anchor.id=pmax(ai, ti), target.id=pmin(ai, ti))
+ 	out<-out[order(out$anchor.id, out$target.id),]
+ 	collected<-diffHic:::.sortedAggregate(out)
+ 
+ 	# Shuffling the counts.
+ 	original <- collected
+ 	reorder <- nrow(collected):1 
+ 	collected <- collected[reorder,]
+ 	keep <- 1:nrow(collected) %% 3 == 0L
+ 	temp <- collected$anchor.id[keep]
+ 	collected$anchor.id[keep] <- collected$target.id[keep]
+ 	collected$target.id[keep] <- temp
+ 
+ 	# Simulating the fragment IDs.
+ 	blah<-GRanges(sample(paste0("chr", 1:nchrs), nfrags, replace=TRUE), IRanges(1:nfrags, 1:nfrags+10),
+ 		seqinfo=Seqinfo(seqnames=paste0("chr", 1:nchrs)))
+ 	blah<-sort(blah)
+ 	newdir<-file.path(tmp, "output")
+ 	savePairs(collected, newdir, fragments=blah)
+ 
+ 	# Checking if everything makes sense.
+ 	chrs<-as.character(seqnames(blah))
+ 	indices <- h5ls(newdir)
+ 	indices <- indices[indices$otype=="H5I_DATASET",]
+ 	regot <- list()	
+ 	for (x in 1:nrow(indices)) {
+ 		reread<-h5read(newdir, file.path(indices$group[x], indices$name[x]))
+ 		for (y in 1:ncol(reread)) { attributes(reread[,y]) <- NULL }
+ 		regot[[x]] <- reread
+ 		comp<-diffHic:::.sortedAggregate(reread, mode="sum")
+ 		stopifnot(identical(comp, reread))
+ 
+ 		uniq.a<-unique(chrs[reread[,1]])
+ 		uniq.t<-unique(chrs[reread[,2]])
+ 		if (length(uniq.a)!=1L || length(uniq.t)!=1L) { stop("file contains more than one combination") }			
+ 		if (basename(indices$group[x])!=uniq.a || indices$name[x]!=uniq.t) { stop("file contains the incorrect combination") }
+ 	}
+ 
+ 	# Checking that the stored result is the same.
+ 	regot <- do.call(rbind, regot)
+ 	regot <- regot[order(regot$anchor.id, regot$target.id),]
+ 	rownames(original) <- rownames(regot) <- NULL 
+ 	stopifnot(identical(original, regot))
+ 	head(regot)
+ }
> 
> savecomp(100, 10, 5)
  anchor.id target.id count
1         1         1     1
2         2         1     5
3         3         1     1
4         3         2     2
5         3         3     2
6         4         1     1
> savecomp(100, 10, 15)
  anchor.id target.id count
1         1         1     1
2         2         1     3
3         3         1     1
4         3         2     3
5         4         1     3
6         4         2     3
> savecomp(100, 10, 25)
  anchor.id target.id count
1         1         1     2
2         3         1     2
3         3         2     3
4         3         3     1
5         4         1     3
6         4         2     2
> savecomp(10, 100, 5)
  anchor.id target.id count
1        55        43     1
2        59        38     1
3        61         4     1
4        71        30     1
5        74        44     1
6        84        30     1
> savecomp(10, 100, 15)
  anchor.id target.id count
1        13         6     1
2        39        21     1
3        56        20     1
4        70        16     1
5        77        60     1
6        80        16     1
> savecomp(10, 100, 25)
  anchor.id target.id count
1         9         6     1
2        36         8     1
3        48         5     1
4        66        53     1
5        76        22     1
6        77        48     1
> savecomp(50, 50, 5)
  anchor.id target.id count
1         6         1     1
2         8         7     2
3         9         4     1
4        10         3     1
5        14         7     1
6        15         1     1
> savecomp(50, 50, 15)
  anchor.id target.id count
1         7         7     1
2         9         8     1
3        11         1     1
4        13         9     1
5        14         3     1
6        14        11     1
> savecomp(50, 50, 25)
  anchor.id target.id count
1         7         5     1
2         8         6     1
3         9         7     1
4        15         2     1
5        17         1     1
6        17         9     1
> 
> ####################################################################################################
> # Finally, chekcing the merging algorithms.
> 
> mergecomp<-function(nl, n, nfrags, nchrs) {
+ 	blah<-GRanges(sample(paste0("chr", 1:nchrs), nfrags, replace=TRUE), IRanges(1:nfrags, 1:nfrags+10),
+ 		seqinfo=Seqinfo(seqnames=paste0("chr", 1:nchrs)))
+ 	blah<-sort(blah)
+ 	allfiles<-list()
+ 	allcounts<-list()
+ 	for (x in 1:nl) {
+ 		# Simulating the dudes (target<=anchor at all times).
+ 		ai<-as.integer(runif(n, 1, nfrags))
+ 		ti<-as.integer(runif(n, 1, nfrags))
+ 		out<-data.frame(anchor.id=pmax(ai, ti), target.id=pmin(ai, ti))
+ 		out<-out[order(out$anchor.id, out$target.id),]
+ 		collected<-diffHic:::.sortedAggregate(out)
+ 		allcounts[[x]]<-collected
+ 		allfiles[[x]]<-  file.path(tmp, paste0("output_", x))
+ 		savePairs(collected, allfiles[[x]], fragments=blah)
+ 	}
+ 	
+ 	# Comparing the combined with a more brutal merger.		
+ 	allfiles<-unlist(allfiles)
+ 	allcounts<-do.call(rbind, allcounts)
+ 	allcounts<-allcounts[order(allcounts[,1], allcounts[,2]),]
+ 	allcounts<-diffHic:::.sortedAggregate(allcounts, mode="sum")
+ 	mdir<-file.path(tmp, "output_merged")
+ 	mergePairs(allfiles, mdir)
+ 	rdir<-file.path(tmp, "output_ref")
+ 	savePairs(allcounts, rdir, fragments=blah)
+ 
+ 	# Comparing internal objects.
+ 	combodirs<-c(mdir, rdir)
+ 	out<-diffHic:::.loadIndices(combodirs)
+ 	for (x in names(out)) {
+ 		for (y in names(out[[x]])) {
+ 			current<-out[[x]][[y]]
+ 			stopifnot(all(current))
+ 			stopifnot(identical(h5read(mdir, file.path(x, y)), h5read(rdir, file.path(x, y))))
+ 		}
+ 	}
+ 
+ 	return(head(allcounts))
+ }
> 
> mergecomp(2, 100, 10, 5)
  anchor.id target.id count
1         1         1     1
2         2         1     7
3         2         2     2
4         3         1     4
5         3         2     7
6         3         3     4
> mergecomp(3, 100, 10, 15)
  anchor.id target.id count
1         1         1     7
2         2         1     4
3         2         2     7
4         3         1     8
5         3         2     9
6         3         3     6
> mergecomp(4, 100, 10, 25)
  anchor.id target.id count
1         1         1    13
2         2         1     9
3         2         2     8
4         3         1     8
5         3         2     7
6         3         3     6
> mergecomp(3, 10, 100, 5)
  anchor.id target.id count
1        21        16     1
2        24         5     1
3        25        18     1
4        30         4     1
5        30        24     1
6        45        22     1
> mergecomp(4, 10, 100, 15)
  anchor.id target.id count
1        16        15     1
2        20         3     1
3        21         8     1
4        28        22     1
5        38         6     1
6        39        30     1
> mergecomp(2, 10, 100, 25)
  anchor.id target.id count
1        30        15     1
2        36        17     1
3        41        31     1
4        52        11     1
5        54        14     1
6        57        49     1
> mergecomp(4, 50, 50, 5)
  anchor.id target.id count
1         4         1     1
2         5         1     1
3         7         3     1
4         9         1     1
5         9         2     1
6         9         3     1
> mergecomp(2, 50, 50, 15)
  anchor.id target.id count
1         5         3     1
2         9         7     1
3        10         7     1
4        11         6     1
5        12         9     1
6        14        11     1
> mergecomp(3, 50, 50, 25)
  anchor.id target.id count
1         5         2     1
2         9         7     1
3        10         5     1
4        10         7     1
5        11        10     1
6        12         8     1
> 
> ####################################################################################################
> # Cleaning up.
> 
> unlink(tmp, recursive=TRUE)
> 
> ####################################################################################################
> 
> 
> 
> proc.time()
   user  system elapsed 
 17.606   0.447  18.132 
