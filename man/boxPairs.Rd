\name{boxPairs}
\alias{boxPairs}

\title{Put bin pairs into boxes}
\description{Match smaller bin pairs to the larger bin pairs in which they are nested.}

\usage{
boxPairs(..., reference)
}

\arguments{
\item{...}{one or more named \code{DIList} objects produced by \code{\link{squareCounts}}, with smaller bin sizes than \code{reference}}
\item{reference}{an integer scalar specifying the reference bin size}
}

\value{
A list object containing:
\item{indices}{a named list of integer vectors for every \code{DIList} in the ellipsis, see Details} 
\item{pairs}{a \code{DIList} describing the parent bin pairs in which the input bin pairs are nested}
}

\details{
Consider the bin size specified in \code{reference}. 
Pairs of these bins are referred to here as the parent bin pairs, and are described in the output \code{pairs} and \code{region}.
The function accepts a number of \code{DIList} objects of bin pair data in the ellipsis, referred to here as input bin pairs.
The aim is to identify the parent bin pair in which each input bin pair is nested.

All input \code{DIList} objects in the ellipsis must be constructed carefully.
In particular, the value of \code{width} in \code{\link{squareCounts}} must be such that \code{reference} is an exact multiple of each \code{width}.
This is necessary to ensure complete nesting.
Otherwise, the behaviour of the function will not be clearly defined.

Some users may wish to identify bin pairs in one \code{DIList} that are nested within bin pairs in another \code{DIList}.
This can be done by supplying both \code{DIList} objects in the ellipsis, and leaving \code{reference} unspecified.
The value of \code{reference} will be automatically selected as the largest width of the supplied \code{DIList} objects.
It is then a trivial matter to \code{\link{match}} the output indices for the smaller bin pairs to the output indices of the larger bin pairs.
}

\section{Explaining the return value}{
One vector will be present in the output \code{indices} for each input \code{DIList} in the ellipsis.
In each vector, each entry represents an index for a single input bin pair in the corresponding \code{DIList}.
This index points to a row of \code{pairs} and indicates the parent bin pair in which that input bin pair is nested.

The \code{pairs} object holds the coordinates of each parent bin pair.
Note that the counts in this \code{DIList} are repurposed here.
Each parent bin pair corresponds to a row of the count matrix, whereas each input \code{DIList} corresponds to a column.
Each entry specifies the number of nested bin pairs in the parent for the corresponding input \code{DIList}.
Similarly, the \code{totals} vector contains the total number of input bin pairs in each input \code{DIList}.
All columns/entries are named according to the name of the corresponding input \code{DIList}.
}

\seealso{
\code{\link{squareCounts}}
}

\author{
Aaron Lun
}

\examples{
# Setting up the objects.
a <- 10
b <- 20
cuts <- GRanges(rep(c("chrA", "chrB"), c(a, b)), IRanges(c(1:a, 1:b), c(1:a, 1:b)))
param <- pairParam(cuts)

all.combos <- combn(length(cuts), 2) # Bin size of 1.
y <- DIList(matrix(0, ncol(all.combos), 1), anchors=all.combos[2,],
    targets=all.combos[1,], regions=cuts, exptData=List(param=param, width=1))

a5 <- a/5
b5 <- b/5
all.combos2 <- combn(length(cuts)/5, 2) # Bin size of 5.
y2 <- DIList(matrix(0, ncol(all.combos2), 1), anchors=all.combos2[2,],
    targets=all.combos2[1,], exptData=List(param=param, width=5),
	regions=GRanges(rep(c("chrA", "chrB"), c(a5, b5)), 
		IRanges(c((1:a5-1)*5+1, (1:b5-1)*5+1), c(1:a5*5, 1:b5*5))))

# Clustering.
boxPairs(reference=5, larger=y2, smaller=y)
boxPairs(reference=10, larger=y2, smaller=y)
boxPairs(larger=y2, smaller=y)
}

\keyword{clustering}
