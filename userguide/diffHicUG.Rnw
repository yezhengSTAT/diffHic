\documentclass[12pt]{report}
\usepackage{fancyvrb,graphicx,natbib,url,comment,import,bm}
\usepackage{tikz}

% Margins
\topmargin -0.1in
\headheight 0in
\headsep 0in
\oddsidemargin -0.1in
\evensidemargin -0.1in
\textwidth 6.5in
\textheight 8.3in

% Sweave options
\usepackage{Sweave}
\SweaveOpts{keep.source=TRUE,prefix.string=plots-ug/ug,png=TRUE,pdf=FALSE}

\DefineVerbatimEnvironment{Sinput}{Verbatim}{fontshape=sl,fontsize=\footnotesize}
\DefineVerbatimEnvironment{Soutput}{Verbatim}{fontsize=\footnotesize}
\DefineVerbatimEnvironment{Scode}{Verbatim}{fontsize=\footnotesize}
%\fvset{listparameters={\setlength{\topsep}{0pt}}}
\renewenvironment{Schunk}{\vspace{0pt}}{\vspace{0pt}}

\DefineVerbatimEnvironment{Rcode}{Verbatim}{fontsize=\footnotesize}
\newcommand{\edgeR}{edgeR}
\newcommand{\csaw}{csaw}
\newcommand{\pkgname}{diffHic}
\newcommand{\code}[1]{{\small\texttt{#1}}}
\newcommand{\R}{\textsf{R}}

% Defining a comment box.
\usepackage{framed,color}
\definecolor{shadecolor}{rgb}{0.9, 0.9, 0.9}
\newenvironment{combox}
{ \begin{shaded}\begin{center}\begin{minipage}[t]{0.95\textwidth} }
{ \end{minipage}\end{center}\end{shaded} }


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\title{\pkgname{}: Differential analysis of ChIA-PET data \\ \vspace{0.2in} User's Guide}
\author{Aaron Lun}

% Set to change date for document, not compile date.
\date{First edition 12 December 2012\\
\vspace{6pt}
Last revised 27 September 2014}

% Removing the bibliography title so it shows up in the contents.
\makeatletter
\renewenvironment{thebibliography}[1]{%
%     \section*{\refname}%
%      \@mkboth{\MakeUppercase\refname}{\MakeUppercase\refname}%
      \list{\@biblabel{\@arabic\c@enumiv}}%
           {\settowidth\labelwidth{\@biblabel{#1}}%
            \leftmargin\labelwidth
            \advance\leftmargin\labelsep
            \@openbib@code
            \usecounter{enumiv}%
            \let\p@enumiv\@empty
            \renewcommand\theenumiv{\@arabic\c@enumiv}}%
      \sloppy
      \clubpenalty4000
      \@clubpenalty \clubpenalty
      \widowpenalty4000%
      \sfcode`\.\@m}
     {\def\@noitemerr
       {\@latex@warning{Empty `thebibliography' environment}}%
      \endlist}
\makeatother

\begin{document}
\maketitle
\tableofcontents

<<results=hide,echo=FALSE>>=
dir.create("plots-ug")
@

\newpage

\chapter{Introduction}
\section{Scope}
This document describes the analysis of Hi-C data with the \pkgname{} package.
Differential interactions are defined as those with significant changes in intensity between conditions.
These are identified in a statistically rigorous manner using the methods in the \edgeR{} package \citep{edgeR}.
Knowledge of \edgeR{} is useful but is not necessary for this guide.

\section{How to get help}
Most questions about individual functions should be answered by the documentation.
For example, if you want to know more about \code{preparePairs}, you can bring up the documentation by typing \code{?preparePairs} or \code{help(preparePET)} at the \R{} prompt.
Otherwise, try reading this guide or contacting one of the authors for more information.
Considered suggestions for improvements are occasionally appreciated.

\section{A brief description of Hi-C}
The Hi-C protocol was originally developed by \cite{lieberman2009comprehensive}.
It is used to study chromatin organization by identifying pairwise interactions between two distinct genomic loci.
Briefly, chromatin is cross-linked and digested with a restriction enzyme.
This releases chromatin complexes into solution, where each complex contains multiple restriction fragments corresponding to interacting loci.
Overhangs are filled in with biotin-labelled nucleotides to form blunt ends.
Proximity ligation is performed whereby ligation between blunt ends in the same complex is favoured.
The ligated DNA is sonicated and the fragments of DNA containing ligation junctions are purified by a biotin pulldown.
The ligation product is then subjected to paired-end sequencing.
Mapping of the reads in each pair can identify the interacting loci.
Of course, some caution is required due to the presence of non-specific ligation between blunt ends in different complexes.

\section{Quick start}
A typical differential analysis of Hi-C data is described below.
For simplicity, assume that the the BAM files have already been processed into index files in \code{input}.
Let \code{design} contain the design matrix for this experiment.
Also assume that the boundaries of the relevant restriction fragments are present in \code{fragments}.
The code itself is split across several steps: 

<<echo=FALSE>>=
input <- c("merged_flox_1.h5", "merged_flox_2.h5", "merged_ko_1.h5", "merged_ko_2.h5")
fragments <- readRDS("mm10-hindIII.rds")
design <- model.matrix(~factor(c("flox", "flox", "ko", "ko")))
@

% saveRDS(fragments, file="mm10-hindIII.rds")

\begin{enumerate}
\item converting BAM files to index files
\item counting read pairs into pairs of genomic bins
<<>>=
require(diffHic)
param <- pairParam(fragments=fragments)
data <- squareCounts(input, width=1e6, param=param)
@
\item filtering out uninteresting bin pairs
<<>>=
require(edgeR)
keep <- aveLogCPM(asDGEList(data)) > 0
data <- data[keep,]
@
\item normalizing counts between libraries
<<>>=
y <- asDGEList(data)
y$offset <- normalize(data, type="loess")
@
\item modelling biological variability
<<>>=
y <- estimateDisp(y, design)
fit <- glmQLFit(y, design, robust=TRUE)
@
\item testing for significant differences between groups
<<>>=
result <- glmQLFTest(fit)
@
\end{enumerate}
In the various examples for this guide, data will be used from three studies. 
The first dataset is smaller and examines the chromatin structure in K562 and GM06990 cell lines \citep{lieberman2009comprehensive}.
The second compares interaction intensities between wild-type and cohesin-deficient murine neural stem cells \citep{sofueva2013cohesin}. 
The final study  compares ERG-overexpressing RWPE1 cells with a GFP-expressing control \citep{rickman2012oncogene}.
Obviously, readers will have to modify the code for their own analyses.

\chapter{Preparing index files from BAM files}
\label{chap:prep} 

\begin{combox}
Hello, dear reader.
A little box will appear at the start of each chapter, describing the objects that are required from the previous chapter.
As we're starting out here, we don't really need anything except your enthusiasm.
\end{combox}

\section{A comment on aligning Hi-C libraries}
In a typical Hi-C library, sequencing will occasionally be performed over the ligation junction between two restriction fragments.
This forms a chimeric read that contains sequences from two distinct genomic loci.
Correct alignment of the $5'$ end of the read is more important.
This is because the location of the $3'$ end is already provided by the location of the $5'$ end of the mate read.
Direct application of alignment software will not be optimal as only one mapping location will be usually reported for each read.
This means that the $5'$ location will be ignored if the $3'$ alignment is superior, e.g., longer or fewer mismatches.

Alignment of chimeric reads can be achieved with approaches like iterative mapping \citep{imakaev2012iterative} or read splitting \citep{seitan2013cohesin}.
The latter defines the ligation signature as the sequence that is obtained after ligation between blunt ends derived from cleaved restriction sites.
For example, the \textit{Hin}dIII enzyme cleaves at \texttt{AAGCTT} with a 4 bp overhang.
This yields a signature sequence of \texttt{AAGCTAGCTT} upon ligation of blunt ends.
The ligation signature in each chimeric read is identified with cutadapt \citep{martin2011cutadapt}, and the read is split into two segments at the center of the signature.
Each segment is then aligned separately to the reference genome using Bowtie2 \citep{langmead2012bowtie}.
Mapping by read splitting can be performed in \pkgname{} using a custom Python script, below.

<<results=hide>>=
system.file("python", "presplit_map.py", package="diffHic", mustWork=TRUE)
@

Users are strongly recommended to synchronize mate pair information and to mark duplicate read pairs in the resulting BAM file.
This can be achieved using the various tools in the Picard software suite (\url{http://picard.sourceforge.net}).

\section{Matching mapped reads to restriction fragments}
The Hi-C protocol is based on ligation between restriction fragments, i.e., the genomic interval between adjacent restriction sites \citep{lieberman2009comprehensive}.
Sequencing of the ligation product is performed to identify the interacting loci -  or, more precisely, the two restriction fragments containing the interacting loci.
The resolution of Hi-C data is inherently limited by the frequency of restriction sites and the size of the restriction fragments.
Thus, it makes sense to report the read alignment location in terms of the restriction fragment to which that read was mapped.
The boundaries of each restriction fragment can be obtained with the \code{cutGenome} function, as shown below for the human genome after digestion with the \textit{Hin}dIII restriction enzyme (recognition site of \code{AAGCTT}, $5'$ overhang of 4 bp).

<<>>=
require(BSgenome.Hsapiens.UCSC.hg19)
hs.frag <- cutGenome(BSgenome.Hsapiens.UCSC.hg19, "AAGCTT", 4)
hs.frag
@

These fragments should be stored in a \code{pairParam} object.
The constructor below will automatically check the validity of the ordering of the fragments. 
The object can also hold several other parameters for use in read pair counting, later.
This simplifies coordination of the various steps in the \pkgname{} pipeline, as the same \code{pairParam} object can be easily passed between different functions. 

<<>>=
hs.param <- pairParam(hs.frag)
hs.param
@

The \code{preparePairs} function can be used to match the mapping location of each read to a restriction fragment.
Mapping results for each read in each pair are provided as a name-sorted BAM file.
The function then converts the read position into the index of the corresponding entry in \code{hs.frag}.
The resulting pairs of indices are stored in an index file using the HDF5 format.
The larger index is designated as the ``anchor'' whereas the smaller is the ``target''.
This is demonstrated using Hi-C data from GM06990 cells.

<<>>=
preparePairs("SRR027957.bam", hs.param, file="SRR027957.h5", dedup=TRUE, minq=10)
@

The function itself returns a list of diagnostics showing the number of read pairs that are lost for various reasons.
Of particular note is the removal of reads that are potential PCR duplicates with \code{dedup=TRUE}.
This requires marking of the reads beforehand using an appropriate program such as Picard's \textsf{MarkDuplicates}.
Filtering on the minimum mapping quality score with \code{minq} is also recommended to remove spurious alignments.

Read pairs mapping to the same restriction fragment provide little information on interactions between fragments.
Dangling ends are inward-facing read pairs that are mapped to the same fragment \citep{belton2012hic}.
These are uninformative as they are usually formed from sequencing of the restriction fragment prior to ligation.
Self-circles are outward-facing read pairs that are formed when two ends of the same restriction fragment ligate to one another.
Interactions within a fragment cannot be easily distinguished from these self-circularization events.
Both structures are removed to avoid downstream confusion.

\section{Processing of chimeric reads}
For \code{preparePairs}, chimeric reads are handled by recording two separate alignments for each read.
Hard clipping is used to denote the length trimmed from each sequence in each alignment, and to determine which alignment corresponds to the $5'$ or $3'$ end of the read.
Only the $5'$ end(s) will be used to determine the restriction fragment index for that read pair.
The total number of chimeric read pairs will be reported, along with the number where $5'$ ends or $3'$ ends are mapped.
Of course, the function will just work normally if the mapping location is only given for the $5'$ end, e.g., as with iterative mapping.

The proportion of invalid chimeric pairs can also be calculated.
Invalid pairs are those where the $3'$ location of a chimeric read disagrees with the $5'$ location of the mate.
The invalid proportion can be used as an empirical measure of the mapping error rate - or, at least, the upper bound of the error rate, given that split alignments are less reliable than those using the full read sequence.
Invalid chimeric pairs can be discarded by setting \code{ichim=FALSE} in \code{preparePairs}.
However, this is not recommended as mapping errors for short $3'$ ends may result in invalidity and loss of the otherwise correct $5'$ alignments.

\section{Filtering artifactual read pairs}

\subsection{Reprocessing index files for quality control}
The \code{prunePairs} function removes read pairs that correspond to artifacts in the Hi-C procedure.
The returned vector contains the number of read pairs removed for each artifact.
Values of \code{length}, \code{inward} and \code{outward} correspond to removal by \code{max.frag}, \code{min.inward} and \code{min.outward}, respectively.
Retained read pairs are stored in another index file for later use.

<<>>=
min.inward <- 1000
min.outward <- 25000
prunePairs("SRR027957.h5", hs.param, file.out="SRR027957_trimmed.h5", 
    max.frag=600, min.inward=min.inward, min.outward=min.outward)
@

The \code{max.frag} argument removes read pairs where the inferred length of the sequencing fragment (i.e., the ligation product) is greater than a specified value.
The length of the sequencing fragment is inferred by summing the distance between the mapping location of the $5'$ end of each read and the nearest restriction site on the $3'$ end of that read.
Excessively large lengths are indicative of offsite cleavage, i.e., where the restriction enzyme or some other agent cuts the DNA at a location other than the restriction site.
While not completely uninformative, these are discarded as they are not expected from the Hi-C protocol.
The threshold value can be chosen based on the size selection interval in library preparation.

The insert size is defined as the linear distance between two paired reads on the same chromosome.
The \code{min.inward} paramater removes inward-facing intra-chromosomal read pairs where the insert size is less than the specified value.
The \code{min.outward} parameter does the same for outward-facing intra-chromosomal read pairs.
This is designed to remove dangling ends or self-circles involving DNA fragments that have not been completely digested \citep{jin2013highres}.
Such read pairs are technical artifacts that are (incorrectly) missed by \code{preparePairs}, as the two reads involved are mapped to different restriction fragments.

\subsection{Setting parameter values with strand orientation plots}
\label{sec:strorient}
The strand orientation for a read pair refers to the combination of strands for the anchor/target reads.
These are stored as flags where setting \code{0x1} or \code{0x2} means that the anchor or target reads, respectively, are mapped on the reverse strand.
If different pieces of DNA were randomly ligated together, one would expect to observe equal proportions of all strand orientations. 
This can be tested by examining the distribution of strand orientations for inter-chromosomal read pairs with \code{getPairData}.
Each orientation is equally represented, which is expected as different chromosomes represent different pieces of DNA.

<<>>=
diags <- getPairData("SRR027957.h5", hs.param)
intra <- !is.na(diags$insert)
table(diags$orientation[!intra])
@

This can be repeated for intra-chromosomal read pairs, by plotting the distribution of insert sizes for each strand orientation \citep{jin2013highres}.
The two same-strand distributions are averaged for convenience.
At high insert sizes, the distributions will converge for all strand orientations.
This is consistent with random ligation between two separate restriction fragments.
At lower insert sizes, spikes are observed in the ouward- and inward-facing distributions due to self-circularization and dangling ends, respectively.
These are not removed by \code{preparePairs} as the read pairs are not mapped to the same restriction fragment.
Rather, the artifacts are formed from incompletely digested fragments.
Thresholds should be chosen in \code{prunePairs} to remove these spikes, as represented by the grey lines.

<<eval=FALSE,label=strorient>>=
llinsert <- log2(diags$insert + 1L)
intra <- !is.na(llinsert)
breaks <- seq(min(llinsert[intra]), max(llinsert[intra]), length.out=30)
inward <- hist(llinsert[diags$orientation==1L], plot=FALSE, breaks=breaks)
outward <- hist(llinsert[diags$orientation==2L] ,plot=FALSE, breaks=breaks)
samestr <- hist(llinsert[diags$orientation==0L | diags$orientation==3L], plot=FALSE, breaks=breaks)
samestr$counts <- samestr$counts/2
ymax <- max(inward$counts, outward$counts, samestr$counts)/1e6
xmax <- max(inward$mids, outward$mids, samestr$mids)
xmin <- min(inward$mids, outward$mids, samestr$mids)

plot(0,0,type="n", xlim=c(xmin, xmax), ylim=c(0, ymax),
    xlab=expression(log[2]~"[insert size (bp)]"), ylab="Frequency (millions)")
lines(inward$mids, inward$counts/1e6, col="darkgreen", lwd=2)
abline(v=log2(min.inward), col="darkgrey")
lines(outward$mids, outward$counts/1e6, col="red", lwd=2)
abline(v=log2(min.outward), col="darkgrey", lty=2)
lines(samestr$mids, samestr$counts/1e6, col="blue", lwd=2)
legend("topright", c("inward", "outward", "same"), col=c("darkgreen", "red", "blue"), lwd=2)
@

\setkeys{Gin}{width=0.6\textwidth}
\begin{center}
<<echo=FALSE,fig=TRUE>>=
<<strorient>>
@
\end{center}
\setkeys{Gin}{width=0.8\textwidth}

It is possible that these spikes reflect some genuine aspect of chromatin organization.
For example, the spike in the outward-facing read pairs may be the result of systematic outward looping in chromatin packaging.
Removal of the spikes would preclude the detection of such features.
Nonetheless, filtering is still recommended to prevent genuine interactions from being dominated by technical artifacts.
Indeed, even if there are imbalances in the strand orientations for any one genuine interaction, these skews should balance out when read pairs from all interactions are considered (i.e., systematic preferences assumed to be absent).

As an aside, the position of the spikes in the above plots can be used to estimate some fragment lengths.
The $x$-coordinate of the outward-facing spike represents the length of the DNA fragments after restriction digestion.
This is useful as it provides a lower bound on the spatial resolution of any given Hi-C experiment.
The position of the inward-facing spike represents the length of the fragments after sonication, i.e., those actually used in sequencing.
This should be lower than the size selection thresholds used in library preparation.

\section{Merging technical replicates}
Hi-C experiments often involve deep sequencing as read pairs are sparsely distributed across the possible interactions.
As a result, multiple index files may be generated from multiple technical replicates of a single Hi-C library.
These can be merged together using the \code{mergePairs} function prior to downstream processing.
This is equivalent to summing the counts for each pair of restriction fragment indices, and is valid if one assumes Poisson sampling for each sequencing run \citep{marioni2008rnaseq}.
An example is provided below that merges several technical replicates for a GM06990 library in the \citeauthor{lieberman2009comprehensive} dataset.

<<>>=
prepped <- preparePairs("SRR027958.bam", hs.param, file="SRR027958.h5", 
    dedup=TRUE, minq=10)
counted <- prunePairs("SRR027958.h5", hs.param, file.out="SRR027958_trimmed.h5", 
    max.frag=600, min.inward=min.inward, min.outward=min.outward)
mergePairs(files=c("SRR027957_trimmed.h5", "SRR027958_trimmed.h5"), "merged.h5")
@

In addition, any Hi-C dataset that is processed manually by the user can be stored in an index file using the \code{savePairs} function.
This takes a dataframe with anchor and target indices, as well as any additional information that might be useful.
The idea is to allow entry into the \pkgname{} analysis from other pipelines.
If the dataset is too large, one can save chunks at a time before merging them all together with \code{mergePairs}.

<<>>=
anchor.id <- as.integer(runif(100, 1, length(hs.param$fragments)))
target.id <- as.integer(runif(100, 1, length(hs.param$fragments)))
dummy <- data.frame(anchor.id, target.id, other.data=as.integer(runif(100, 1, 100)))
savePairs(dummy, "example.h5", hs.param)
@

For full compatability, users should include the alignment positions and lengths as \code{xxx.pos} and \code{xxx.len} (replacing \code{xxx} with \code{anchor} or \code{target}).
The alignment position refers to the 1-based coordinate of the left-most base of the alignment.
The alignment length refers to the span of the alignment relative to the reference, and should be negative for alignments on the reverse strand.
This information should be stored for both the anchor and target alignments.
It is more useful for other \pkgname{} functions than some arbitrary \code{other.data}.

\chapter{Counting read pairs into interactions}
\label{chap:counting}

\begin{combox}
A different dataset is used in this chapter, so we really don't need anything from the previous chapter.
Just stay enthused, because this is where the fun starts.
\end{combox}

\section{Overview}
Prior to any statistical analysis, the read pairs in a Hi-C library must be summarized into a count for each interaction.
This count is used as an experimental measure of the interaction intensity.
Specifically, each pairwise interaction is parameterized by two genomic intervals representing the interacting loci.
The count for that interaction is defined as the number of read pairs with one read mapping to each of the intervals.
This must be performed for each sample in the dataset, such that each interaction is associated with a set of counts.

The interaction space is defined as the genome-by-genome space over which read pairs are distributed.
This refers to the space of all index pairs $(x, y)$ for $x, y \in [1 .. N]$, where $x \ge y$ and $N$ is the number of restriction fragments in the genome.
A rectangular area in the interaction space represents a pairwise interaction between the genomic intervals spanned by the two adjacent sides of the rectangle.
The number of read pairs in each area is then used as the count for the corresponding interaction.
Non-rectangular areas can also represent interactions, but these are more difficult to interpret and will not be considered here.

The examples shown here will use the \citeauthor{sofueva2013cohesin} dataset.
Read processing has already been performed to construct an index file for each library.
Some additional work is required to obtain the restriction fragment coordinates for the \textit{Hin}dIII-digested mouse genome.

<<>>=
require(BSgenome.Mmusculus.UCSC.mm10)
mm.frag <- cutGenome(BSgenome.Mmusculus.UCSC.mm10, "AAGCTT", 4)
input <- c("merged_flox_1.h5", "merged_flox_2.h5", "merged_ko_1.h5", "merged_ko_2.h5")
@

\section{Counting into bin pairs}

\subsection{Overview}
Here, the genome is partitioned into contiguous non-overlapping bins of constant size.
Each interaction is defined as a pair of these bins.
This approach avoids the need for prior knowledge of the loci of interest when summarizing Hi-C counts.
Counting of read pairs between bin pairs can be performed for multiple libraries using the \code{squareCounts} function.

<<>>=
bin.size <- 1e6
mm.param <- pairParam(mm.frag)
data <- squareCounts(input, mm.param, width=bin.size, filter=1)
data
@

This generates a \code{DIList} object containing the relevant information.
Each row of the count matrix represents the counts for an interaction, while each column represents a library.
Each interaction is characterized as a pair of genomic intervals, i.e., bins.
Again, anchor and target notation is used for these intervals, whereby the anchor bin is that with the higher genomic coordinate.
The total vector just contains the total number of read pairs in each library.

Bin pairs can also be filtered to remove those with to a count sum below \code{filter}.
This removes uninformative bin pairs with very few read pairs, and reduces the memory footprint of the function.
A higher value of \code{filter} may be necessary for analyses of large datasets with limited memory.
More sophisticated filtering strategies are discussed in Chapter~\ref{chap:filter}.

\subsection{Choosing a bin width}
The \code{width} of the bin is specified in base pairs and determines the spatial resolution of the analysis.
Smaller bins will have greater spatial resolution as adjacent features can be distinguished in the interaction space.
Larger bins will have greater counts as a larger area is used to collect read pairs.
Optimal summarization will not be achieved if bins are too small or too large to capture the (changes in) intensity of the underlying interactions.

Determination of the ideal bin size is not trivial as the features of interest are not usually known in advance.
Instead, repeated analyses with multiple bin sizes are recommended.
This provides some robustness to the choice of bin size.
Sharp interactions can be detected by pairs of smaller bins while diffuse interactions can be detected by larger bin pairs.
See Section~\ref{sec:mergebins} for more information on consolidating results from multiple bin sizes.

<<>>=
head(regions(data))
@

The boundary of each bin is rounded to the closest restriction site in \code{squareCounts}.
This is due to the inherent limits on spatial resolution in a Hi-C experiment.
The number of restriction fragments in each bin is recorded in the \code{nfrags} field of the metadata.

\section{Counting with pre-defined regions}
For some studies, prior knowledge about the regions of interest may be available.
For example, a researcher may be interested in examining interactions between genes.
The coordinates can be obtained from existing annotation, as shown below for the mouse genome.
Other pre-specified regions can also be used, e.g., known enhancers or protein binding sites.

<<>>=
require(org.Mm.eg.db)
chrstart <- toTable(org.Mm.egCHRLOC)
chrend <- toTable(org.Mm.egCHRLOCEND)
gene.body <- GRanges(paste0("chr", chrstart$Chromosome),
    IRanges(abs(chrstart$start_location), abs(chrend$end_location)))
@

Counting can be directly performed for these defined regions using the \code{connectCounts} function.
Interactions are defined between each pair of regions in the pre-specified set.
This can be easier to interpret than pairs of bins as the interacting regions have some biological significance.
The count matrix and the vector of totals are defined as previously described.

<<>>=
redata <- connectCounts(input, mm.param, regions=gene.body)
redata
@

Again, anchor and target notation applies whereby the interval with the larger start coordinate in the genome is defined as the anchor.
Note that the anchor may not have a larger end coordinate if the supplied \code{regions} are nested.
In addition, each region is rounded to the nearest restriction site.
Resorting is also performed, though the indices of the original regions can be found in the metadata as \code{original} if back-referencing is necessary.

<<>>=
head(regions(redata))
@

One obvious limitation of this approach is that interactions involving unspecified regions will be ignored.
This is obviously problematic when searching for novel interacting loci.
Another issue is that the width of the regions cannot be easily changed.
This means that the compromise between spatial resolution and count size cannot be tuned.
For example, interactions will not be detected around smaller genes as the counts will be too small.
Conversely, interactions between distinct loci within a single large gene body will not be resolved.

\section{Counting into single bins}
\label{sec:marginal}
For each bin, the number of read pairs with at least one read mapped inside that bin can be counted with the \code{marginalCounts} function.
This effectively uses the Hi-C data to examine the genomic coverage of each bin.
One can use these ``marginal'' counts to determine whether there are systematic differences in coverage between libraries for a given bin.
This implies that copy number variations are present, which may confound the differential analysis.

<<>>=
margin.data <- marginCounts(input, mm.param, width=bin.size)
margin.data
@

For this dataset, there are no major changes in coverage for the vast majority of bins.
The most extreme events occur at low abundances and are unlikely to be reliable.
This suggests that a direct comparison of interaction intensities will be valid.
Remedial action in the presence of copy number changes is not trivial and will be discussed in Section~\ref{sec:copy}.

<<eval=FALSE,label=mamargin>>=
adjc <- cpm(asDGEList(margin.data), log=TRUE, prior.count=5)
smoothScatter(0.5*(adjc[,1]+adjc[,3]), adjc[,1]-adjc[,3],
    xlab="A", ylab="M", main="Flox (1) vs. Ko (1)")
@

\setkeys{Gin}{width=0.6\textwidth}
\begin{center}
<<fig=TRUE,echo=FALSE>>=
<<mamargin>>
@
\end{center}
\setkeys{Gin}{width=0.8\textwidth}

It must be stressed that the marginal count refers to a count for each bin. 
To avoid any confusion, the count for each \textit{bin pair} will be described as the interaction count.
Later, it may be necessary to adjust the interaction count based on the marginal counts for the corresponding bins (Section~\ref{sec:copy}, for example).
In such cases, one should ensure that the same values of \code{width} and \code{fragments} are used in both \code{squareCounts} and \code{marginCounts}.
One can check that this is the case by ensuring that the regions are the same.

<<>>=
identical(regions(data), regions(margin.data))
@

Note that the anchor/target notation is superfluous for \code{marginCounts}.
This is because the marginal counts refer to individual bins rather than bin pairs.
Nonetheless, a \code{DIList} is still returned for consistency, in which the anchor and target regions are identical.

\section{Additional parameter options}

\subsection{Restricting the input chromosomes}
Users can elect to restrict counting to particular chromosomes, by setting a value for the \code{restrict} slot in the \code{pairParam} object.
This is useful to ensure that only interactions between relevant chromosomes are loaded.
Sequences such as the mitochondrial genome, unassigned contigs or random chromosome segments can be ignored.

<<>>=
new.param <- reform(mm.param, restrict=c("chr1", "chr2"))
new.param
@

\subsection{Specifying regions to ignore}
Users can also choose to discard alignments that lie within blacklisted regions, using the \code{discard} slot.
The aim is to eliminate reads within known repeat regions.
Reads from several repeat units in a real genome may be collated into a single representative unit in the genome build.
This results in a sharp spike in read intensity, incorrectly suggesting a sharp feature in the interaction space.
The problem is exacerbated by different repeat copy numbers between conditions, resulting in spurious differential interactions due to changes in coverage.
Removal of reads in these repeats may be necessary to obtain reliable results.

<<>>=
dummy.repeat <- GRanges("chr1", IRanges(10000, 1000000))
new.param <- reform(new.param, discard=dummy.repeat)
new.param
@

The coordinates of the repeat regions can be obtained from various sources.
The simplest approach is to extract them from an appropriate \code{BSgenome} object. 
The example below takes the repeats called by the RepeatMasker program in the hg19 build of the human genome.
Alternatively, blacklisted regions can be used from the ENCODE project \citep{landt2012chipseq}.

<<>>=
require(BSgenome.Hsapiens.UCSC.hg19.masked)
bs <- BSgenome.Hsapiens.UCSC.hg19.masked
all.masks <- list()
for (i in 1:length(seqnames(bs))) { 
    cur.chr <- seqnames(bs)[i]
    all.masks[[i]] <- GRanges(cur.chr, masks(bs[[cur.chr]])$RM)
}
suppressWarnings(do.call(c, all.masks))
@

\subsection{Capping the read pairs per restriction fragment pair}
Incomplete removal of PCR duplicates or read pairs repeat regions may result in spikes of read pairs within the interaction space.
The effect of these artifacts can be mitigated by capping the number of read pairs associated with each pair of restriction fragments.
This is done by specifying a value for the \code{cap} slot.
Diffuse interactions should not be affected, as the associated read pairs will be distributed sparsely across many fragment pairs.
More caution is required if sharp interactions are present, i.e., interactions between 5 - 10 kbp regions.

<<>>=
new.param <- reform(mm.param, cap=5)
new.param
@

\section{Summary}
Counting into bin pairs is the most general method for interaction quantification.
It does not require any prior knowledge regarding the regions of interest.
The bin size can be easily adjusted to obtain the desired spatial resolution.
It is also easier/safer to compare between bin pairs (e.g., during filtering) when each bin is roughly of the same size.
Thus, bin-based counting will be the method of choice for the rest of this guide.

For simplicity, all counting steps will be performed here with the default settings, i.e., no values for \code{restrict}, \code{discard} or \code{cap}.
However, users are encouraged to change the values if necessary, to improve the outcome of their analyses.
Non-default values should be recorded in a single \code{pairParam} object for consistent use across all functions in the \pkgname{} pipeline.
This ensures that the same read pairs are extracted from each index file.

% On a side note, it's worth checking that the total library sizes are the same for each method if multiple counting functions are used.
% This means that the same read pairs are being used for count extraction.
% 
% <<>>=
% rbind(totals(data), totals(re.data), totals(margin.data))
% @

\chapter{Filtering out uninteresting interactions}
\label{chap:filter}

\begin{combox}
Here, we'll need the \code{data} object that was loaded in the previous chapter.
We'll also need \code{bin.size} and \code{mm.frag}.
Enthusiasm is desirable, but no longer necessary.
\end{combox}

\section{Overview}

\subsection{Computing the average abundance in a NB model}
Filtering can remove uninteresting features in analyses of high-throughput experiments. 
This reduces the severity of the multiple testing correction and increases detection power among the remaining tests. 
The filter statistic should be independent of the $p$-value under the null hypothesis, but correlated to the $p$-value under the alternative \citep{bourgon2010independent}. 
The aim is to enrich for false nulls without affecting type I error for the true nulls. 

Assume that the counts for each bin pair are sampled from the negative binomial (NB) distribution.
Here, the overall NB mean across all libraries is (probably) an independent filter statistic.
This is also called the average abundance and can be computed using the \code{aveLogCPM} function in \edgeR{} \citep{mccarthy2012glm}, as shown below.

<<eval=FALSE,label=avehistplot>>=
require(edgeR)
ave.ab <- aveLogCPM(asDGEList(data))
hist(ave.ab, xlab="Average abundance")
@

\setkeys{Gin}{width=0.5\textwidth}
\begin{center}
<<echo=FALSE,fig=TRUE>>=
<<avehistplot>>
@
\end{center}
\setkeys{Gin}{width=0.8\textwidth}

Any bin pair with an average abundance less than a specified threshold value will be discarded.
At the very least, the threshold should be chosen to filter out bin pairs with very low absolute counts.
This is because these bin pairs will never have sufficient evidence to reject the null hypothesis.
Low counts will also interfere with the asymptotic approximations that will be used in downstream statistical modelling.
The example below removes those bin pairs with an overall NB mean below 5 across all libraries.

<<>>=
count.keep <- ave.ab >= aveLogCPM(5, mean(totals(data)))
summary(count.keep)
dummy <- data[count.keep,]
@

This count-based approach is fairly objective yet is still effective, i.e., removes a large number of bin pairs. 
More sophisticated strategies can be implemented where the choice of threshold is motivated by some understanding of the Hi-C protocol.
These strategies are described in the rest of this chapter, and will be combined with the count-based filter to maintain a minimum count size among the retained bin pairs.

Here, the filtered results are assigned into the \code{dummy} object.
This avoids overwriting the original data at this point in the guide.
Similarly, \code{dummy} will be used as a dumping ground for the various demonstrations below.
However, when actual filtering is desired, the filtered results should be assigned back to the \code{data} object for further analysis.

\subsection{Computing the interaction distance}
The linear distance between each pair of the interacting bins is worth mentioning as it can also be used in filtering.
This is obtained using the \code{getDistance} function, which computes the distance between the bin midpoints by default.

<<eval=FALSE,label=distplot>>=
dist <- getDistance(data, type="mid")
hist(dist/1e6, xlab="Distance (Mbp)")
@

\setkeys{Gin}{width=0.5\textwidth}
\begin{center}
<<echo=FALSE,fig=TRUE>>=
<<distplot>>
@
\end{center}
\setkeys{Gin}{width=0.8\textwidth}

Inter-chromosomal bin pairs are marked here as \code{NA} for completeness.
These tend to dominate the output as they constitute most of the interaction space.
Of course, the majority of these bin pairs will have low counts due to the sparseness of the data.

<<>>=
summary(is.na(dist))
@

%The second statistic is the area of the interaction space that is covered by each bin pair.
%This can be easily computed with the \code{getArea} function.
%Each area is returned in terms of pairs of restriction fragments, in keeping with the resolution limits of the Hi-C protocol.
%Larger areas should be associated with greater counts as more restriction fragments are available for ligation.
%
%<<eval=FALSE,label=areaplot>>=
%area <-getArea(data)
%hist(area, xlab="Pairs of restriction fragments")
%@
%
%\setkeys{Gin}{width=0.5\textwidth}
%\begin{center}
%<<echo=FALSE,fig=TRUE>>=
%<<areaplot>>
%@
%\end{center}
%\setkeys{Gin}{width=0.8\textwidth}
%
%Differences in areas can be roughly normalized between bin pairs by dividing each average count with its corresponding area.
%This produces a normalized abundance that can be compared between bin pairs.
%Of course, this does not account for other differences between bins, e.g., in mappability or sequenceability.
%The same caveat applies for area-based divisions elsewhere in the chapter.
%
%<<>>=
%norm.ab <- ave.ab - log2(area)
%@

\section{Directly removing low-abundance interactions}
\label{sec:direct}
The simplest definition of an ``uninteresting'' interaction is that resulting from non-specific ligation. 
These are represented by low-abundance bin pairs where no underlying interaction is present to drive ligation between the corresponding bins. 
Any changes in the counts for these bin pairs are not interesting and are ignored.
In particular, the filter threshold can be defined by mandating some minimum fold change above the level of non-specific ligation.

The magnitude of non-specific ligation can be empirically estimated by assuming that most inter-chromosomal contacts are not genuine. 
This is reasonable given that most chromosomes are arranged in self-interacting territories \citep{bickmore2013spatial}.
The median abundance across inter-chromosomal bin pairs is used as the estimate of the non-specific ligation rate. 
The threshold is defined by requiring a minimum fold change of 10 above this estimate.

<<>>=
direct.threshold <- median(ave.ab[is.na(dist)], na.rm=TRUE)
direct.keep <- count.keep & ave.ab > log2(10) + direct.threshold
dummy <- data[direct.keep,]
summary(direct.keep)
@

The \code{direct.keep} vector can then be applied for filtering of \code{data}, as previously shown with \code{count.keep}.
This approach is named here as ``direct'' filtering, as the average count is directly compared against a fixed threshold value.
Note that the construction of \code{direct.keep} is based off \code{count.keep} to ensure that retained bins have large absolute counts.

\section{Filtering as a function of interaction distance}
A more complex filter adjusts the threshold according to the distance between the bins in each bin pair. 
Larger counts are observed at lower distances, suggesting that a concomitantly higher threshold is necessary. 
This expands the definition of ``uninteresting'' events to include those interactions that are formed by simple compaction of chromatin \citep{lin2012global}.

In this strategy, a trend is fitted to the average abundance for all intra-chromosomal bin pairs using the log-distance as the covariate. 
Half of the bin size is added to the distance as a prior, to avoid undefined values when distances are zero.
Inter-chromosomal bin pairs will not be involved in trend fitting as the distance will be \code{NA}.
Nonetheless, the fitted value for these bin pairs is set to the fitted value of the largest intra-chromosomal distance.

<<>>=
log.dist <- log10(dist + bin.size/2)
trend.threshold <- loessFit(x=log.dist, y=ave.ab)$fitted
trend.threshold[is.na(log.dist)] <- trend.threshold[which.max(log.dist)]
@

The effect of this strategy can be visualized by plotting the interaction distance against the normalized abundance.
A power-law relationship between distance and abundance is typically observed in Hi-C data \citep{lieberman2009comprehensive}. 
The average abundance (and thus, the filter threshold) decreases as the distance between the interacting loci increases.

<<eval=FALSE,label=avedistplot>>=
smoothScatter(log.dist, ave.ab, xlab="Log-Distance", ylab="Normalized abundance")
o <- order(log.dist)
lines(log.dist[o], trend.threshold[o], col="red", lwd=2)
@

\setkeys{Gin}{width=0.5\textwidth}
\begin{center}
<<echo=FALSE,fig=TRUE>>=
<<avedistplot>>
@
\end{center}
\setkeys{Gin}{width=0.8\textwidth}

The assumption here is that the majority of interactions are generated by non-specific packaging of the linear genome.
Each bin pair is only retained if its abundance is greater than the corresponding fitted value at that distance, i.e., the intensity is above that expected from compaction.  
This favours selection of bin pairs corresponding to long-range interactions.

<<>>=
trend.keep <- count.keep & ave.ab > trend.threshold
dummy <- data[trend.keep,]
summary(trend.keep)
@

% This is what they effectively do in Lin's paper. They compute the expected
% counts using a distance function to boost up the value, and then they test
% for significant differences from the expected value.

%\section{Filtering by local abundance}
%Finally, one can consider interesting events as spikes in read pair density in the interaction space \citep{jin2013high}. 
%This defines the filter threshold for each bin pair based on the average count across all the neighbouring bin pairs in the interaction space. 
%Neighbour counts can be computed with the \code{countNeighbors} function, as shown below.
%The \code{flank} argument specifies the maximum distance (in terms of bins) to which other bin pairs are considered neighbours.
%
%<<>>=
%surrounds <- countNeighbors(data, flank=1)
%neighbor.ab <- aveLogCPM(surrounds$counts, lib.size=data$total)
%@
%
%Each bin pair will only be retained if its average count is greater than that of most of its neighbours.
%In this case, a 2-fold increase in each bin pair over its neighbours is required for retention. 
%However, some adjustment is required to account for the difference in the areas between each bin pair and its neighbours.
%This can be achieved by simply dividing the neighbourhood abundance by the neighbourhood area.
%
%<<>>=
%local.threshold <- neighbor.ab - log2(surrounds$n)
%local.keep <- count.keep & norm.ab > local.threshold + log2(2)
%summary(local.keep)
%@
%
%Diffuse contacts between two broad regions are deemed to be uninteresting and are removed in favour of sharp interactions.
%This is equivalent to calling peaks of high interaction intensity in the interaction space.

\section{Computing filter thresholds with limited memory}
These filtering procedures assume that no filtering has been performed during count loading with \code{squareCounts}, i.e., \code{filter} is set to unity.
Any pre-filtering that removes low-abundance bin pairs will lead to overestimation of the filter thresholds. 
However, it may not be practical to load counts without pre-filtering, e.g., for small bin sizes where too many non-empty bin pairs are present.
In such cases, two options are available:
\begin{itemize}
\item Pick an arbitrary threshold and use it to directly filter on the average abundances.
This is simple but the chosen threshold has no obvious interpretation.
\item Load counts for larger bin sizes without pre-filtering.
This reduces memory usage as the interaction space is partitioned into fewer bin pairs.
Then, perform filtering and convert the computed filter thresholds into values for the original (smaller) bin sizes.
Estimation of the threshold is also more precise when the counts are larger.
\end{itemize}

An example of the second option is shown here.
For this section, imagine that a bin size of 100 kbp is actually of interest, but filter thresholds can only be efficiently computed with 1 Mbp bins.
The first task is to load the counts for the smaller bin pairs.
A non-unity value of \code{filter} is set in \code{squareCounts} to avoid using too much memory.

<<>>=
new.bin.size <- 1e5
smaller.data <- squareCounts(input, mm.param, width=new.bin.size, filter=20)
@

The threshold for the larger bin pairs are computed as previously described.
However, this must be adjusted to account for the differences in the read counting area of the interaction space.
A quick and dirty adjustment can be obtained by squaring the ratio of the bin sizes.
An example is shown below, using the threshold from direct filtering.

<<>>=
deflation <- (new.bin.size/bin.size)^2
new.threshold <- direct.threshold + log2(deflation)
@

The average abundance of the smaller bin pairs must also be computed with some consideration of the differences in bin size.
Specifically, the prior count must be scaled down before addition.
This avoids spurious differences in the abundances of small and large bin pairs after downscaling of the latter.
If the same prior is used, downscaling of the abundances for large bin pairs will reduce the size of the effective prior added to those counts.

<<>>=
small.ab <- aveLogCPM(asDGEList(smaller.data), prior.count=prior.count*deflation) 
@

Finally, filtering is performed by mandating a minimum fold change for the abundances of the smaller bin pairs over the adjusted threshold (in this case, 100-fold).
More bin pairs are retained here, as the total number of bin pairs is greater when the bin sizes are smaller.
Also recall that a large \code{filter} is used in \code{squareCounts} to generate \code{smaller.data}.
This means that no additional filtering is necessary to enforce a minimum count size.

<<>>=
small.keep <- small.ab > new.threshold + log2(100)
smaller.data <- smaller.data[small.keep,]
summary(small.keep)
@

The minimum fold change used here is higher than that for the larger bin pairs in Section~\ref{sec:direct}.
This is justified by intepreting the threshold as a significance measure.
Bin pairs are only retained if their abundances are significantly greater than that expected from non-specific ligation.
However, the total number of bin pairs increases when the bin size decreases.
Increasing the stringency of the threshold effectively serves as a multiplicity correction.

% This is a fairly oblique piece of code which uses the interchromosomals as a background distribution.
% Increasing the threshold results in a 100-fold decrease in the number of retained bin pairs from this distribution.
% This acts as the multiplicity correction for the 100-fold increase in total bin pairs with the smaller bins.
% <<>>=
% nspec.distr <- ave.ab[is.na(dist)]
% sum(nspec.distr > direct.threshold+log2(10))
% sum(nspec.distr > direct.threshold+log2(100))
% @
% To see the necessity of this, consider reducing the bin size down to a single fragment.
% This would reduce the expected background intensity well below 1, due to the severity of the adjustment.
% This means that any bin pair with a count in it would be retained at the old log-fold change.
% This is obviously nonsensical, as bin pairs must be either 0 or not zero.
% In short, just using the expected value doesn't account for the distribution of observed values.

The same strategy can be used in trended filtering by replacing \code{direct.threshold} with \code{trended.threshold}.
However, some additional effort is required to match the threshold at each covariate.
This is done by performing interpolation (and, if necessary, extrapolation) of the fitted distance-abundance trend for the distances of the smaller bin pairs.
The computed \code{new.threshold2} can then be used to replace \code{new.threshold} in the code snippets above.

<<>>=
new.log.dist <- log10(getDistance(smaller.data) + new.bin.size/2)
new.trended <- approx(x=log.dist, y=ave.ab, xout=new.log.dist, rule=2)$y
new.trended[is.na(new.log.dist)] <- new.trended[which.max(new.log.dist)]
new.threshold2 <- new.trended + log2(deflation)
@

\section{Filtering for pre-specified regions}
The methods described above for calculation of filter thresholds rely on bin pair counts.
Filtering for pairs of arbitrary regions is slightly more difficult as the width of the regions is not guaranteed to be reasonably constant.
One must adjust the threshold for the differences in the read counting areas, as shown below with the \code{getArea} function.

<<>>=
re.ab <- aveLogCPM(asDGEList(redata))
re.norm.ab <- re.ab - log2(getArea(redata, mm.param))
summary(re.norm.ab)
@

Filtering can then be performed with \code{re.norm.ab}, in the same manner as described for the bin pairs.
However, users should keep in mind that only a subset of the interaction space is considered here.
Calculation of the filter thresholds may be inaccurate, e.g., if the regions were specified such that only high-abundance areas are counted.
Similarly, threshold estimation may be imprecise if not enough areas are non-empty.
%Finally, local filtering is also impossible as \code{countNeighbors} depends on regularly spaced bins.

Technically, filtering with bin pairs should also be performed after adjusting for the area of each bin pair.
This is because some bins may match up to fewer restriction fragments, despite all bins having similar base pair widths.
In practice, this is unnecessary for large bins as the vast majority will contain similar numbers of restriction fragments.
Indeed, area-based adjustment prior to filtering is not recommended for routine analyses.
This is because it tends to select for bins with very few fragments, e.g., telomeres, centromeres.

<<label=nfragplot,eval=FALSE>>=
hist(getArea(data), breaks=100, xlab="Restriction fragments per bin")
@

\setkeys{Gin}{width=0.5\textwidth}
\begin{center}
<<echo=FALSE,fig=TRUE>>=
<<nfragplot>>
@
\end{center}
\setkeys{Gin}{width=0.8\textwidth}

Note that area-based adjustment adjustment fails to account for other differences between bins, e.g., in mappability or sequenceability.
Full consideration of these bin-specific biases requires methods such as iterative correction (see Section~\ref{sec:itercor}).

\section{Filtering out diagonal elements}
Incomplete removal of artifacts (e.g., dangling ends, self-circles) will generally manifest as increased counts for diagonal bin pairs, i.e., pairs of the same bin.
If artifact generation and/or removal is not consistent between libraries, the behaviour of the diagonal elements will differ markedly from the other bin pairs.
This can be diagnosed using MA plots between libraries, where the diagonal elements show up as a distinct mass that is unconnected to the rest of the points.
Such irregularities cannot be smoothly normalized and should be removed prior to further analysis, or analyzed separately.
Removal can be achieved by applying the \code{diag.keep} object alongside the direct or trended filters, as shown below.

<<>>=
diag.keep <- is.na(dist) | dist > 0L  
dummy <- data[diag.keep & direct.keep,]
summary(diag.keep)
@

Obviously, this will also remove short-range interactions that might be of interest.
Users are advised to use a smaller bin size to recover these interactions.
Artifacts will still be restricted to diagonal bin pairs, so long as the bins are larger than $\sim$25 kbp (see Section~\ref{sec:strorient}).
Short-range interactions will then be represented by the remaining off-diagonal bin pairs, due to the improved spatial resolution of smaller bins.
While count sizes will also decrease, this should not be a major problem as counts should be larger at low interaction distances. 

\section{Summary of the filtering strategies}
Each filtering strategy is arbitrarily tunable, as one can simply increase or decrease the minimum fold change required for retention.
Nonetheless, they are still useful as they can guide the user towards a sensible interpretation of the filter threshold.
This would not be possible if the threshold value was just arbitrarily chosen.
The effect of each approach can also be summarized by examining the distribution of interaction distances after filtering.

<<eval=FALSE,label=filterdist>>=
mod.dist <- dist/1e6
all.breaks <- hist(mod.dist, plot=FALSE)$breaks
hist(mod.dist[direct.keep], breaks=all.breaks, col=rgb(0,0,1,0.3))
hist(mod.dist[trend.keep], breaks=all.breaks, col=rgb(1,0,0,0.3), add=TRUE)
@

\setkeys{Gin}{width=0.5\textwidth}
\begin{center}
<<echo=FALSE,fig=TRUE>>=
<<filterdist>>
@
\end{center}
\setkeys{Gin}{width=0.8\textwidth}

As expected, the direct method preferentially retains short-range interactions whereas the trended method selects for long-range interactions.
The choice of filtering method depends on the features that are most likely to be of interest in each analysis.
In general, less aggressive filtering should be performed if these features are not well defined.
Here, a tentative recommendation is provided for retention of short-range interactions, given that short-range packaging dominates genomic organization.
On a practical level, the simplicity of the direct approach is attractive and will be used throughout the rest of the guide.

%Note that the local method predominantly selects interactions on the diagonal of the interaction space (i.e., self-interactions).
%This is because these have much higher intensities than their off-diagonal neighbours.
%As a result, it does not enrich for the interactions that are actually desired, i.e., sharp long-range contacts.
%These are presumably rare in Hi-C data.

<<>>=
original <- data
data <- data[direct.keep,]
@

As promised, the filtered results are assigned back into \code{data}.
This is mostly for consistency, so that all operations are performed on \code{data} in the rest of this guide.
The original unfiltered data is retained for later use in Section~\ref{sec:itercor}, but can otherwise be ignored.

\chapter{Normalization strategies for Hi-C data}

\begin{combox}
Here, we're using the \code{data} object that was filtered in the previous chapter.
We'll also need the \code{original} object, as well as \code{margin.data} from Section~\ref{sec:marginal}.
Another human dataset will be loaded here, so \code{hs.frag} from Chapter~\ref{chap:prep} will be required.
\end{combox}

\section{Removing trended biases between libraries}
Library-specific biases can be generated from uncontrolled differences in library preparation. 
This is particularly problematic for Hi-C data given the complexity of the protocol. 
Changes in cross-linking efficiency or ligation specificity can lead to a systematic redistribution of read pairs throughout the interaction space. 
For example, reduced specificity may result in more counts for weak non-specific interactions, and fewer counts for strong genuine interactions.
Such biases may manifest as an abundance-dependent trend in a MA plot between replicates.

<<echo=FALSE,eval=FALSE,label=makema>>=
mval <- adj.counts[,3]-adj.counts[,1]
smoothScatter(ab, mval, xlab="A", ylab="M", main="KO (1) vs. Flox (1)")
fit <- loessFit(x=ab, y=mval)
lines(ab[o], fit$fitted[o], col="red")
@

<<eval=FALSE,label=maunnorm>>=
ab <- aveLogCPM(asDGEList(data))
o <- order(ab)
adj.counts <- cpm(asDGEList(data), log=TRUE)
<<makema>>
@

\setkeys{Gin}{width=0.5\textwidth}
\begin{center}
<<echo=FALSE,fig=TRUE>>=
<<maunnorm>>
@
\end{center}
\setkeys{Gin}{width=0.8\textwidth}

Trended biases are problematic as they can inflate the variance estimates or fold-changes for some bin pairs. 
Thus, they must be eliminated with non-linear normalization.
The code below uses the NB-loess method, which is an adaptation of existing non-linear methods for discrete count data \citep{normpaper}.
An offset term is computed for each bin pair in each library, for use in a generalized linear model (GLM). 
A large offset for an observation is equivalent to downscaling the corresponding count relative to the counts of the other libraries. 

<<>>=
nb.off <- normalize(data, type="loess")
head(nb.off)
@

The MA plot can be examined after adjusting the log-counts with the offsets.
Most of the trend is removed which indicates that normalization was successful.
Of course, this assumes that most bin pairs at each abundance do not represent differential interactions.
Any systematic differences between libraries are assumed to be technical in origin and are removed.
If this assumption does not hold, genuine differences may be lost upon normalization.

<<eval=FALSE,label=manorm>>=
adj.counts <- log2(counts(data) + 0.5) - nb.off/log(2)
<<makema>>
@

\setkeys{Gin}{width=0.5\textwidth}
\begin{center}
<<echo=FALSE,fig=TRUE>>=
<<manorm>>
@
\end{center}
\setkeys{Gin}{width=0.8\textwidth}

Filtering on average abundance prior to normalization is strongly recommended.
This removes low counts and avoids problems with discreteness.
Filtering also improves the sensitivity of span-based fitting algorithms like LOESS at higher abundances.
Otherwise, the fitted trend will be dominated by the majority of low-abundance bin pairs.

\section{Iterative correction of interaction intensities}
\label{sec:itercor}
While this is not the intended function of the \pkgname{} package, a method is also provided for the removal of biases between genomic regions.
The \code{correctedContact} function performs the iterative correction procedure described by \cite{imakaev2012iterative} with some modifications.
Briefly, if multiple libraries are used to generate the \code{data} object, then correction is performed using the overall NB mean for each bin pair.
Winsorizing through \code{winsor.high} is also performed to mitigate the impact of high-abundance bin pairs.

<<>>=
corrected <- correctedContact(original, winsor.high=0.02, ignore.low=0.02)
head(corrected$truth)
@

The returned \code{truth} contains the ``true'' contact probability for each bin pair in \code{data}.
This is designed to account for differences in sequencibility, mappability, restriction site frequency, etc. between bins.
Comparisons can then be directly performed between the contact probabilities of different bin pairs.
Some \code{NA} values will be present due to the removal of low-abundance bins that do not exhibit stable behaviour during correction.

Note that \code{original} is used as no filtering should be performed prior to \code{correctedContact}.
All non-empty bin pairs are needed for correction as information is collected across the entire interaction space.
The contribution of many bin pairs with low counts is as substantial as that of few bin pairs with large counts.
The convergence of the correction procedure can then be checked by examining the maximum fold change to the truth at each iteration.

<<>>=
corrected$max
@

Of course, iterative correction only removes biases between different bins.
It is not guaranteed to remove (trended) biases between libraries.
For example, two replicates could have the same genomic biases but a different distribution of read pairs in the interaction space, e.g., due to differences in ligation specificity.
The latter would result in a trended bias, but iterative correction would have no effect due to the identical genomic biases.
In short, normalization within a library is a different problem from normalization between libraries.

% For example, consider two replicates in which ve the same genomic biases.
% Assume that the Hi-C protocol was more efficient in the second replicate, such that more weak long-range interactions were captured (at the expense of the strong short-range interactions).
% This is visualized below with plots of the genome-by-genome interaction space for each replicate, where the counts represent the relative intensity of each interaction.
% 
% \setkeys{Gin}{width=0.49\textwidth}
% \begin{center}
% <<fig=TRUE,echo=FALSE>>=
% plot(0, 0, xlim=c(0, 3), ylim=c(0, 3), xlab="genome", ylab="genome", type="n",axes=FALSE, 
%     cex.lab=2, main="Replicate 1", cex.main=2)
% curmat1 <- rbind(c(3, 0, 0), c(1, 3, 0), c(1, 1, 3))
% keep <- lower.tri(curmat1, diag=TRUE)
% xs <- nrow(curmat1) - row(curmat1)[keep] + 1
% ys <- col(curmat1)[keep]
% my.colors <- rgb(1, 0, 0, c(0.3, 0.6, 0.9))
% rect(xs-1, ys-1, xs, ys, col=my.colors[curmat1[keep]], lty=2)
% text(xs-0.5, ys-0.5, labels=curmat1[keep], cex=2)
% @
% <<fig=TRUE,echo=FALSE>>=
% plot(0, 0, xlim=c(0, 3), ylim=c(0, 3), xlab="genome", ylab="genome", type="n",axes=FALSE, 
%     cex.lab=2, main="Replicate 2", cex.main=2)
% curmat2 <- rbind(c(2, 0, 0), c(2, 2, 0), c(2, 2, 2))
% rect(xs-1, ys-1, xs, ys, col=my.colors[curmat2[keep]], lty=2)
% text(xs-0.5, ys-0.5, labels=curmat2[keep], cex=2)
% @
% \end{center}
% \setkeys{Gin}{width=0.8\textwidth}
% 
% Interactions are shown between pairs of genomic intervals, based on the partitioning of each axis by the dotted lines.
% A fold change of 1.5 will be obtained at an average intensity of 2.5 for the diagonal elements, whereas a fold change of 0.5 will be obtained at an average intensity of 1.5 for all other elements.
% This mean-dependent fold change represents a trended bias that can be eliminated with non-linear methods.
% In contrast, the sum of counts for each genomic interval is the same for all intervals in each replicate ($1 + 3 + 1$ for the first and $2 + 2 + 2$ for the second).
% This means that iterative correction will have no effect as it operates on the differences in these sums within a single sample.

% A related single-sample approach deserves special mention. Normalization can
% be performed on the distances between bins in each pair \cite{ay2014} to
% correct for the drop in interaction frequency with increasing distance between
% loci. As the distance is negatively correlated with abundance, normalization
% to standardize the former between libraries will also reduce differences in 
% counts with respect to the latter. 
%     That said, given the choice, it is preferable to model a weak relative 
% trend between libraries rather than a strong absolute trend for each library.
% This is because any errors in fitting will be smaller in the former. Moreover,
% you'd end up using the distance for normalization in the same way that you're
% using the abundance.  The distance itself has no inherently appealing
% qualities, it's only its relation to the abundance which is interesting for
% single-sample analyses. For differential analyses, why go second-best? You can
% use the abundance directly and skip the middleman.

\section{Accounting for copy number variations}
\label{sec:copy}

\subsection{Eliminating CNVs with multi-dimensional smoothing}
Copy number variations (CNVs) in the interacting regions will also affect the interaction intensity. 
These CNV-driven differences in intensities are generally uninteresting and must be removed to avoid spurious detection.
This is done using the \code{normalizeCNV} function, which simultaneously removes trended biases as well.
The function is based on multi-dimensional smoothing across several covariates with the \code{locfit} package \citep{loader1999local}.

<<>>=
cnv.offs <- normalizeCNV(data, margin.data)
head(cnv.offs)
@

Three covariates are defined for each bin pair.
For a pair of libraries, the ratio of marginal counts for each bin can be used as a proxy for the relative CNV between libraries in that bin.
Each bin pair will be associated with two of these marginal log-ratios to use as covariates.
Note that the marginal counts should be collected with the same parameters as the interaction counts.
The third covariate for each bin pair is that of the average abundance across all libraries.
This will account for any abundance-dependent trends in the biases.

The response for each bin pair is defined as the log-ratio of interaction counts between a pair of  libraries.
A locally weighted surface is fitted to the response against all three covariates for all bin pairs.
At any combination of covariate values, most bin pairs are assumed to represent non-differential interactions.
Any systematic differences between libraries are attributed to CNV-driven (or trended) biases and are removed.
Specifically, GLM offsets are returned and can be supplied to the statistical analysis to eliminate the bias.

\subsection{Why use multi-dimensional smoothing?}
The use of a empirical fit reduces the number of assumptions involved in translating a CNV into its effect on interaction intensities.
For example, iterative correction could correct for CNVs by accounting for differences in coverage of each bin.
However, converting the change in coverage into a quantifiable change in the interaction intensity requires the assumption of factorizability \citep{imakaev2012iterative}, i.e., the effect on intensity is a product of the biases of the interacting regions.
This is reasonable under a random ligation model, but does not account for other mechanisms of read pair generation.

The fit must be performed simultaneously with all covariates, to ensure that biases at any combination of covariate values are properly identified (and removed).
That said, the use of many covariates may lead to overfitting and removal of genuine differences.
The function also assumes that CNVs in different parts of the genome have the same effect on the interaction intensities.
Caution is therefore required when using \code{normalizeCNV}. 
The safest choice is to avoid it when CNVs are not present, based on the diagnostic plots in Section~\ref{sec:marginal}.

As an aside, filtering by average abundance is strongly recommended prior to running \code{normalizeCNV}.
This reduces the computational work required for multi-dimensional smoothing.
Discreteness and domination of the fit by low-abundance bin pairs is also avoided.

\subsection{Visualizing the effect of CNV removal}
Here, the \citeauthor{rickman2012oncogene} dataset is used for demonstration as it contains more CNVs.
Interaction counts are loaded for each bin pair, and marginal counts are loaded for each bin.
Some filtering is performed to eliminate low-abundance bin pairs, as previously described.

<<>>=
count.files <- c("merged_erg.h5", "merged_gfp.h5")
rick.data <- squareCounts(count.files, hs.param, width=1e6)
rick.marg <- marginCounts(count.files, hs.param, width=1e6)
rick.data <- rick.data[aveLogCPM(asDGEList(rick.data)) > 0,]
@

The aim is to plot the log-ratio of the interaction counts of each bin pair, as a function of the marginal log-ratios of the corresponding bins.
This will illustrate the effect of the CNV on the interaction intensities between the two libraries.
As two marginal log-ratios are present for each bin pair, these are added together for simplicity.

<<>>=
matched <- matchMargins(rick.data, rick.marg)
m.adjc <- cpm(asDGEList(rick.marg), log=TRUE)
sum.madjc <- m.adjc[matched$amatch,] + m.adjc[matched$tmatch,]
margin.lr <- sum.madjc[,1] - sum.madjc[,2]
@

Plotting can be performed to determine the effect of \code{normalizeCNV}.
The presence of a trend indicates that decreases in copy number result in decreases in interaction intensity.
After normalization, the trend in the interaction log-ratios is removed.
Note that increasing \code{maxk} may be necessary to obtain sufficient accuracy in the internal call to \code{locfit}.

<<eval=FALSE,label=cnvplotter>>=
before <- cpm(asDGEList(rick.data), log=TRUE)
after <- log2(counts(rick.data)+0.5) - normalizeCNV(rick.data, rick.marg, maxk=1000)/log(2)
par(mfrow=c(1,2), cex.axis=1.2, cex.lab=1.4)
smoothScatter(margin.lr, before[,1]-before[,2], ylim=c(-4, 4), main="Before",
    xlab="Sum of marginal log-ratios", ylab="Interaction log-ratio")
smoothScatter(margin.lr, after[,1]-after[,2], ylim=c(-4, 4), main="After",
    xlab="Sum of marginal log-ratios", ylab="Interaction log-ratio")
@

\setkeys{Gin}{width=0.8\textwidth}
\begin{center}
<<echo=FALSE,fig=TRUE,width=10,height=5>>=
<<cnvplotter>>
@
\end{center}
\setkeys{Gin}{width=0.8\textwidth}

% Biases computed by iterative correction represent the divisors that were used to convert the counts into contact probabilities.
% As such, they can be log-transformed and used as GLM offsets.
% The aim is to use the biases to account for changes in copy number within each bin.
% Spurious differences and inflated variances can then be avoided during the statistical analysis.
% 
% Calculation of library-specific offsets from the biases can be performed with the output of \code{correctedContact}.
% This requires setting \code{average=FALSE} such that iterative correction is performed separately for each library.
% Any missing biases for low abundance bins are set to 0, i.e., the mean offset for each bin pair.
% This ensures that further processing can be performed in the absence of information for these bins.
% 
% <<>>=
% corrected <- correctedContact(original, average=FALSE)
% log.bias <- log(corrected$bias)
% log.bias <- log.bias - rowMeans(log.bias, na.rm=TRUE)
% log.bias[is.na(log.bias)] <- 0
% cnv.off <- log.bias[data@anchor.id,,drop=FALSE] + log.bias[data@target.id,,drop=FALSE]
% head(cnv.off)
% @
% 
% It must be stressed that there are several obvious limitations with this approach. 
% In particular:
% \begin{itemize}
% \item Changes in copy number are assumed to have a multiplicative effect on interaction intensity.
% This may not be the case, e.g., a change in copy number may be handled by negative feedback mechanisms such that no change occurs in the interaction intensity.
% \item The correction procedure is usually dominated by contributions from short-range interactions.
% Any stochastic changes in the intensity of these interactions will have an inappropriately large effect on the results for all bin pairs.
% \item There is no simple way to combine these offsets with those from non-linear normalization.
% Indeed, there is no guarantee that the two offsets do not oppose each other's effects.
% \item Some biases cannot be computed for some libraries where they have counts of zero.
% Imputation for missing values is \textit{ad hoc} whereby values are set to the average offset (zero, above).
% \end{itemize}
% An alternative approach is to simply identify the bins that have potential copy number changes.
% This can be done by performing a differential analysis on the counts from \code{marginCounts}.
% Any pairs that involve affected bins can be marked to indicate that caution is required during interpretation.
% This strategy avoids the aforementioned problems and may be preferable when only a few bins are affected.
% 
% % You might be wondering why we just don't divide it through by the coverage 
% % of each bin. However, this is not a good idea. Check out the example below,
% % where a matrix of 1's has been multiplied by a true bias. You need a couple
% % of iterations to recover the true bias, even under true factorizability.
% 
% <<eval=FALSE,echo=FALSE>>=
% true.bias <- c(1.5, 2, 1)
% blah <- t(true.bias * t(matrix(1, 3, 3) * true.bias))
% combined <- 1L
% for (it in 1:25) {
%   collected <- sqrt(rowSums(blah))
%   blah <- t(t(blah/collected)/collected)
%   combined <- combined*collected
%   print(combined/min(combined))
% }
% @

\chapter{Modelling biological variability}

\begin{combox}
In this chapter, the \code{data} object is again required.
The computed offsets in \code{nb.off} will also be used from the last chapter.
This chapter is relaxing as it is quite short and covers familiar territory.
In some respects, it is the calm before the storm.
\end{combox}

\section{Overview}
The magnitude of biological variability can be empirically determined from biological replicates, i.e., Hi-C libraries prepared from different biological samples.
This is used during testing to appropriately reduce the significance of any detected differences when the data is highly variable.
For count-based data, this is achieved using the NB model in \edgeR{} \citep{edgeR}.  
Estimation of the NB dispersion parameter allows modelling of the variation between biological replicates. 
Similarly, estimation of the quasi-likelihood (QL) dispersion can be performed to account for heteroskedasticity \citep{lund2012ql}. 

Dispersion estimation requires the fitting of a GLM to the counts for each bin pair \citep{mccarthy2012glm}. 
This means that a design matrix must be specified to describe the experimental setup.
Here, a simple one-way layout is sufficient.
The code below specifies two groups of two replicates, where each group corresponds to a single cell type.
At this point, the aim is to compute the dispersion from the variability in counts within each group.

<<>>=
design <- model.matrix(~factor(c("flox", "flox", "ko", "ko")))
colnames(design) <- c("Intercept", "KO")
design
@

It is also necessary to assemble a \code{DGEList} object for entry into \edgeR{}.
Note the inclusion of the normalization offsets that were previously computed with the NB-loess method.

<<>>=
y <- asDGEList(data)
y$offset <- nb.off
@

\section{Estimating the NB dispersion}
Estimation of the NB dispersion is performed by maximizing the Cox-Reid adjusted profile likelihood (APL) \citep{mccarthy2012glm} for each bin pair.
Of course, when replication is limited, there is not enough information per bin pair to estimate the dispersion.
This is overcome by computing and sharing APLs across many bin pairs to stablize the estimates.

<<>>=
y <- estimateDisp(y, design)
y$common.dispersion
@

A more sophisticated strategy is also used whereby an abundance-dependent trend is fitted to the APLs.
This should manifest as a smooth trend in the NB dispersion estimates with respect to the average abundances of all bin pairs.
The aim is to improve modelling accuracy by empirically modelling any non-NB mean-variance relationships.

<<eval=FALSE,label=bcvplot>>=
plotBCV(y)
@

\setkeys{Gin}{width=0.6\textwidth}
\begin{center}
<<echo=FALSE,fig=TRUE>>=
<<bcvplot>>
@
\end{center}
\setkeys{Gin}{width=0.8\textwidth}

In most cases, the relationship should be monotonic decreasing as the counts become more precise with increasing size.
Minor deviations are probably due to the imperfect nature of non-linear normalization.
Major increases are indicative of batch effects.
For example, a cluster of outliers indicates that there may be copy number changes between replicates.

\section{Estimating the QL dispersion}
The QL dispersion for each bin pair is estimated from the deviance of the fitted GLM.
This may seem superfluous given that the NB dispersion already accounts for biological variability.
However, the QL dispersion can account for heteroskedasticity between bin pairs, whereas the NB dispersion cannot.
Estimation of the former is performed with the \code{glmQLFit} function.

<<eval=FALSE,label=qlplot>>=
fit <- glmQLFit(y, design, robust=TRUE)
plotQLDisp(fit)
@

Again, there is not enough information for each bin pair for precise estimation.
Instead, information is shared between bin pairs using an empirical Bayes (EB) approach.
Per-bin-pair QL estimates are shrunk towards the mean/trended value across all bin pairs.
This stabilizes the QL dispersion estimates and improves precision for downstream applications.

\setkeys{Gin}{width=0.6\textwidth}
\begin{center}
<<echo=FALSE,fig=TRUE>>=
<<qlplot>>
@
\end{center}
\setkeys{Gin}{width=0.8\textwidth}

The extent of the EB shrinkage is determined by the heteroskedasticity in the data.
If the true dispersions are highly variable, shrinkage to a common value would be inappropriate.
On the other hand, more shrinkage can be performed to increase precision if the true dispersions are not variable.
This variability is quantified as the prior degrees of freedom, for which smaller values correspond to more heteroskedasticity and less shrinkage.

<<>>=
summary(fit$df.prior)
@

It is important to use the \code{robust=TRUE} argument in \code{glmQLFit}.
This protects against any large positive outliers corresponding to highly variable counts.
It also protects against large negative outliers.
These are formed from near-zero deviances when counts are identical, and are not uncommon when counts are low.
In both cases, such outliers would inflate the apparant heteroskedasticity and increase the estimated prior degrees of freedom.

\section{Further information}
More details on the statistical methods in \edgeR{} can be found, unsurprisingly, in the \edgeR{} user's guide.
Of course, \pkgname{} is compatible with any statistical framework that accepts a count matrix and a matrix of log-link GLM offsets.
Advanced users may wish to use methods from other packages.
This author prefers \edgeR{} as it works quite well for routine analyses of Hi-C data.
He also has a chance of being cited when \edgeR{} is involved \citep{chen2014differential}.

\chapter{Testing for significant interactions}

\begin{combox}
This chapter brings everything together.
We need the \code{fit} object from the last chapter, along with the \code{data} object (as usual).
We also require the \code{smaller.data} object from Chapter~\ref{chap:filter}.
Finally, the \code{bin.size} and \code{mm.frag} objects are required from Chapter~\ref{chap:counting}.
\end{combox}

\section{Using the quasi-likelihood F-test}
The \code{glmQLFTest} function performs a QL F-test for each bin pair to identify significant differences.
Users should check that the contrast has been specified correctly through the \code{coef} or \code{contrast} arguments.
In this case, the coefficient of interest refers to the change in the KO counts over the WT counts.
The null hypothesis for each bin pair is that the coefficient is equal to zero, i.e., there is no change between the WT and KO groups.

<<>>=
result <- glmQLFTest(fit, coef=2)
topTags(result)
@

More savvy users might wonder why the likelihood ratio test (LRT) was not used here.
Indeed, the LRT is the more obvious test for any inferences involving GLMs. 
However, the QL F-test is preferred as it accounts for the variability and uncertainty of the QL dispersion estimates \citep{lund2012ql}. 
This means that it can maintain type I error control in the presence of heteroskedasticity, whereas the LRT does not.

\section{Multiplicity correction and the FDR}

\subsection{Overview}
Many bin pairs are tested for differences across the interaction space.
Correction for multiple testing is necessary to avoid detection of many spurious differences.
For genome-wide analyses, this correction can be performed by controlling the false discovery rate (FDR) with the Benjamini-Hochberg (BH) method \citep{benjamini1995fdr}. 
This provides a suitable comprimise between specificity and sensitivity.
In contrast, traditional methods of correction (e.g., Bonferroni) are often too conservative.

\subsection{Direct application of the BH method}
The BH method can be applied directly to the $p$-values for the individual bin pairs. 
In this case, the FDR refers to the proportion of detected bin pairs that are false positives. 
Significantly specific interactions are defined as those that are detected at an FDR of 5\%.

<<>>=
adj.p <- p.adjust(result$table$PValue, method="BH")
sum(adj.p <= 0.05)
@

These can be saved to file as necessary.
Resorting by $p$-value just makes it easier to parse the final table, as the most interesting differential interactions are placed at the top.

<<>>=
ax <- anchors(data)
tx <- targets(data)
final <- data.frame(anchor.chr=seqnames(ax), anchor.start=start(ax), anchor.end=end(ax),
    target.chr=seqnames(tx), target.start=start(tx), target.end=end(tx), 
    result$table, FDR=adj.p)
o <- order(final$PValue)
write.table(final[o,], file="results.tsv", sep="\t", quote=FALSE, row.names=FALSE)
@

\subsection{Aggregating small bin pairs}
Smaller bins provide greater spatial resolution and can identify sharp differential interactions that would otherwise be lost within larger bin pairs.
To demonstrate, a quick-and-dirty analysis of the previously loaded counts for the 100 kbp bin pairs is performed here.

<<>>=
y.small <- asDGEList(smaller.data)
y.small$offset <- normalize(smaller.data, type="loess")
y.small <- estimateDisp(y.small, design)
fit.small <- glmQLFit(y.small, design, robust=TRUE)
result.small <- glmQLFTest(fit.small)
@

Use of smaller bin pairs can be problematic when diffuse interactions are present.
Recall that the FDR refers to the proportion of bin pairs that are false positives.
However, each bin pair is just an analytical construct. 
The more relevant error rate is the FDR across the underlying interactions, as this represents actual biology.
The FDR over bin pairs can be used as a proxy for the FDR over interactions, if one assumes that each bin pair roughly corresponds to an interaction.
This is reasonable for large bin pairs, but is less so when multiple smaller bin pairs are used to represent a diffuse interaction.
This can result in misinterpretation of the FDR such that control is lost \citep{lun2014denovo}.

A typical approach might be to cluster bin pairs in the interaction space to identify the underlying true interaction.
One can then combine $p$-values across all bin pairs in the cluster using Simes' method \citep{simes1986}, to obtain a single combined $p$-value for the cluster.
This approach avoids misinterpretation for diffuse interactions as each cluster (and thus interaction) has one $p$-value.
However, this is confounded by the density of the interaction space, particularly at short distances and/or in TADs.
The boundaries of each cluster become ambiguous and difficult to interpret, e.g., if a whole TAD is absorbed into a cluster.

Boundary ambiguity can be avoided by performing pre-defined clustering based on large bin pairs.
Specifically, a large bin pair is defined and the set of all smaller bin pairs nested therein is defined as a cluster.
This is robust to high-density space as the definition of the cluster does not depend on the neighbouring bin pairs.
Identification of these clusters can be achieved with the \code{boxPairs} function, as shown below.
Note that the larger bin size must be a multiple of the \code{width} used for the smaller bins - in this case, 1 Mbp.

<<>>=
matched <- boxPairs(reference=bin.size, smaller=smaller.data, param=mm.param)
@

The $p$-values for all of the smaller bin pairs can then be combined using Simes' method.
The resulting combined $p$-value represents the evidence against the global null hypothesis for the larger bin pair, i.e., there are no significant differences in any of the smaller bin pairs nested within the larger bin pair.
The BH method is applied to the combined $p$-values to control the FDR across all larger bin pairs/interactions.
Rejection of the global null indicates that there is a change and that the larger bin pair is worth further investigation.

<<>>=
require(csaw)
tabcom <- combineTests(matched$indices$smaller, result.small$table)
head(tabcom)
sum(tabcom$FDR <= 0.05)
@

Of course, bin clustering will not be optimal for diffuse interactions.
One could obtain larger counts with larger bin pairs, given that spatial resolution is not an issue for diffuse interactions.
Nonetheless, bin clustering will protect against misinterpretation when both sharp and diffuse interactions are present.
The use of small bin pairs will allow detection of the former, while bin clustering will prevent distortion of the FDR by the latter.
This method is also a good introduction to the next section, which might be more useful.

\subsection{Merging results from different bin widths}
\label{sec:mergebins}
The choice of bin size is not clear when there are both sharp and diffuse changes in the interaction space.
Robustness can be provided by combining the differential testing results between small and large bin pairs.
All smaller bin pairs that are nested within each of the larger bin pairs are identified using the \code{boxPairs} function.
This yields identifiers for each bin pair where \code{smaller} bin pairs are nested in \code{larger} bin pairs with the same ID.

<<>>=
matched <- boxPairs(bin.size, larger=data, smaller=smaller.data, param=mm.param)
ldex <- matched$indices$larger
sdex <- matched$indices$smaller
@

Each larger bin pair is associated with its own $p$-value and those of the smaller nested bin pairs.
All of these $p$-values can be combined as peviously described.
The idea is to provide a compromise between larger counts and spatial resolution in the final combined $p$-value.

A weighted version of Simes' method is used to compute the combined $p$-value \citep{benjamini1997multiple}.
For each larger bin pair, the weight of the $p$-value for that bin pair is the same as the combined weight of all the smaller nested bin pairs.
This means that the analysis with the larger bin pair has the same contribution to the final combined value as that for the smaller bin pairs.
The aim is to avoid increasing the contribution of the latter simply because there are more smaller bin pairs covering the interaction space.

<<>>=
weight <- c(1/counts(matched$pairs)[sdex,"smaller"],
    1/counts(matched$pairs)[ldex,"larger"])
@

The code snippet above makes sense as the count matrix from the \code{DIList} in \code{boxPairs} records the number of nested bin pairs at each bin size.
So, as the number of nested bin pairs increases, the weight assigned to each bin pair decreases.
Weighted calculation of the combined $p$-value is then performed using the \code{combineTests} function in the \csaw{} package.

<<>>=
result.com <- combineTests(ids=c(sdex, ldex), 
    tab=rbind(result.small$table, result$table), weight=weight)
head(result.com)
@

The BH method is then applied to the combined $p$-values.
The FDR refers to the proportion of larger bin pairs that are false discoveries.
Like before, misinterpretation of the FDR is mitigated by nesting the smaller bin pairs within their larger counterparts.
Note the difference in the results after combining analyses from large and small bin pairs, relative to the analyses using only one bin size.
An increase in the number of detections suggests that the different bin sizes complement each other.
Sharp changes in the interaction space are detected with small bins, whereas diffuse changes are detected with larger bins.

<<>>=
sum(result.com$FDR <= 0.05)
@

% In other cases, decreased power may be observed if either - but not both- sharp or diffuse interactions are observed.
% This is because the effective number of tests increases, along with the severity of the correction.

Statistics for each of the larger bin pairs can then be stored to file. 
Reordering is performed using the combined $p$-value to promote the strongest changes.

<<>>=
ax.2 <- anchors(matched$pairs)
tx.2 <- targets(matched$pairs)
final.2 <- data.frame(anchor.chr=seqnames(ax.2), anchor.start=start(ax.2), 
    anchor.end=end(ax.2), target.chr=seqnames(tx.2), target.start=start(tx.2), 
    target.end=end(tx.2), result.com)
o2 <- order(final.2$PValue)
write.table(final.2[o2,], file="results.2.tsv", sep="\t", quote=FALSE, row.names=FALSE)
@

\subsection{Reporting nested bin pairs}
Whenever nesting is involved, it may be convenient to identify the top-ranked (smaller) nested bin pair within each of the (larger) parent bin pairs.
Here, the top-ranked bin pair is defined as the one with the smallest individual $p$-value.
This means that any high-resolution changes nested within a parent bin pair can be easily identified.
However, users should always keep in mind that the FDR is computed with respect to the parent bin pairs.

<<>>=
inside <- getBestTest(sdex, result.small$table)
best.vec <- rep(NA, nrow(matched$pairs))
best.vec[as.integer(rownames(inside))] <- inside$best
head(best.vec)
ax.3 <- as.data.frame(anchors(smaller.data))[best.vec,]
tx.3 <- as.data.frame(targets(smaller.data))[best.vec,]
nested <- data.frame(anchor.start=ax.3$start, anchor.end=ax.3$end, 
    target.start=tx.3$start, target.end=tx.3$end, 
    result.small$table[best.vec,c("logFC", "F")])
head(nested)
final.3 <- data.frame(final.2, nest=nested)
write.table(final.3[o2,], file="results.3.tsv", sep="\t", quote=FALSE, row.names=FALSE)
@

The above code only reports the top-ranked nested bin pair for each parent.
This may not be sufficient when many internal changes are occurring.
An alternative approach is to store the entirety of the \code{smaller.data} in a \R{} save file, along with \code{matched} and \code{data}.
Any interesting nested changes can then be interactively identified for a given parent.

\section{Visualization with plaid plots}
Plaid plots can be used to visualize the distribution of read pairs in the interaction space \citep{lieberman2009comprehensive}. 
Briefly, each axis is a chromosome segment. 
Each ``pixel'' represents an interaction between the corresponding intervals on each axis. 
The colour of the pixel is proportional to the number of read pairs mapped between the interacting loci.

<<label=plaid1,eval=FALSE,echo=FALSE>>=
plotPlaid(input[1], anchor=expanded.a, target=expanded.t, cap=cap1, 
    width=5e4, col="red", param=mm.param, main="Flox")
rect(start(ax.2[chosen]), start(tx.2[chosen]), end(ax.2[chosen]), end(tx.2[chosen]))
@

<<label=plaid3,eval=FALSE,echo=FALSE>>=
plotPlaid(input[3], anchor=expanded.a, target=expanded.t, cap=cap3, 
    width=5e4, col="blue", param=mm.param, main="KO")
rect(start(ax.2[chosen]), start(tx.2[chosen]), end(ax.2[chosen]), end(tx.2[chosen]))
@

<<eval=FALSE,echo=FALSE,label=setup>>=
chosen <- o2[1]
expanded.a <- resize(ax.2[chosen], fix="center", width=bin.size*5)
expanded.t <- resize(tx.2[chosen], fix="center", width=bin.size*5)
cap1 <- 100
cap3 <- cap1*totals(data)[3]/totals(data)[1]
@

<<eval=FALSE>>=
<<setup>>
<<plaid1>>
<<plaid3>>
@

<<results=hide,echo=FALSE>>=
chosen <- 1
<<setup>>
@

Expansion of the plot boundaries ensures that the context of the interaction can be determined by examining the features in the surrounding space. 
It is also possible to tune the size of the pixels through a parameter that is, rather unsurprisingly, named \code{width}.
In this case, the side of each pixel represents a 50 kbp bin, rounded to the nearest restriction site.
The actual bin pair occurs at the center of the plot and is marked by a rectangle.

\setkeys{Gin}{width=0.48\textwidth}
\begin{center}
<<fig=TRUE,echo=FALSE>>=
<<plaid1>>
@
<<fig=TRUE,echo=FALSE>>=
<<plaid3>>
@
\end{center}
\setkeys{Gin}{width=0.8\textwidth}

The \code{cap} value controls the relative scale of the colours. 
Any pixel with a count above \code{cap} will be set at the maximum colour intensity.
This ensures that a few high-count regions do not dominate the plot.
A smaller \code{cap} is necessary for smaller libraries so that the intensity of the colours is comparable.
The actual colour can be controlled by specifying \code{col}.

In the example above, the differential interaction is driven mainly by the smaller bin pairs.
Changes in intensities are particularly prevalent at the top left and bottom right corners of the rectangle.
By comparison, the fold change for the entire bin pair is a little less than 30\%.
This highlights the usefulness of including analyses with smaller bin sizes.

Another example is shown below.
The following plots are constructed for the top differential interaction using only large bins.
Because the counts are ``averaged'' across the area of the interaction space, the change must be consistent throughout that area (and thus, more obvious) for detection to be successful.
Of course, any sharp changes within each of these large bin pairs will be overlooked as the smaller bin pairs are not used.

<<label=plaid1b,eval=FALSE,echo=FALSE>>=
plotPlaid(input[1], anchor=expanded.a, target=expanded.t, cap=cap1, 
    width=5e4, param=mm.param, col="red", main="Flox")
rect(start(ax[chosen]), start(tx[chosen]), end(ax[chosen]), end(tx[chosen]))
@

<<label=plaid3b,eval=FALSE,echo=FALSE>>=
plotPlaid(input[3], anchor=expanded.a, target=expanded.t, cap=cap3, 
    width=5e4, col="blue", param=mm.param, main="KO")
rect(start(ax[chosen]), start(tx[chosen]), end(ax[chosen]), end(tx[chosen]))
@

<<eval=FALSE,echo=FALSE,label=setup2>>=
chosen <- o[1]
expanded.a <- resize(ax[chosen], fix="center", width=bin.size*5)
expanded.t <- resize(tx[chosen], fix="center", width=bin.size*5)
cap1 <- 30
cap3 <- cap1*totals(data)[3]/totals(data)[1]
@

<<eval=FALSE>>=
<<setup2>>
<<plaid1b>>
<<plaid3b>>
@

<<results=hide,echo=FALSE>>=
<<setup2>>
@

\setkeys{Gin}{width=0.48\textwidth}
\begin{center}
<<fig=TRUE,echo=FALSE>>=
<<plaid1b>>
@
<<fig=TRUE,echo=FALSE>>=
<<plaid3b>>
@
\end{center}
\setkeys{Gin}{width=0.8\textwidth}

Alternatively, users may prefer to use \code{rotPlaid} to generate rotated plaid plots.
These are more space-efficient and are easier to stack onto other genomic tracks, e.g., for ChIP-seq data.
However, rotated plots are only effective for local interactions within a specified region.
Some more effort is also required in interpretation.
In the example below, each coloured box represents an interaction between two bins. 
The coordinates of each interacting bin can be identified by extending lines from opposite sides of the box until they intersect the $x$-axis.

<<eval=FALSE,echo=FALSE,label=rot1>>=
rotPlaid(input[1], mm.param, region=example, width=2e4, 
    main="Flox", col="Red", cap=cap1)
@

<<eval=FALSE,echo=FALSE,label=rot2>>=
rotPlaid(input[3], mm.param, region=example, width=2e4,
    main="KO", col="blue", cap=cap3)
@

<<eval=TRUE,echo=FALSE,label=rotset>>=
chosen <- o2[2]
example <- tx.2[chosen]
end(example) <- end(ax.2[chosen])
nest.mid.a <- (ax.3$start[chosen]+ax.3$end[chosen])/2
nest.mid.t <- (tx.3$start[chosen]+tx.3$end[chosen])/2
nest.mid <- (nest.mid.a + nest.mid.t)/2
nest.gap <- nest.mid.a - nest.mid.t
@

<<eval=FALSE,echo=FALSE,label=enbox>>=
points(nest.mid, nest.gap, cex=7) 
@

<<eval=FALSE>>=
<<rotset>>
<<rot1>>
<<enbox>>
<<rot2>>
<<enbox>>
@

\setkeys{Gin}{width=0.8\textwidth}
\begin{center}
<<fig=TRUE,echo=FALSE,width=10,height=6>>=
<<rot1>>
<<enbox>>
@
<<fig=TRUE,echo=FALSE,width=10,height=6>>=
<<rot2>>
<<enbox>>
@
\end{center}
\setkeys{Gin}{width=0.8\textwidth}

The circle marks the area of the interaction space that corresponds to the top-ranked nested bin pair within the \code{chosen} larger bin pair.
An increase in the interaction intensity is clearly observed in the KO condition.
This sharp change would not be observed with larger bin pairs, where the final count would be dominated by other (non-differential) areas.

\chapter{Epilogue}

\section{Data sources}
All datasets are publicly available from the NCBI Gene Expression Omnibus (GEO).
The \citeauthor{lieberman2009comprehensive} dataset was obtained using the GEO accession number GSE18199.
The \citeauthor{sofueva2013cohesin} dataset was obtained using the GEO accession GSE49017.
Finally, the \citeauthor{rickman2012oncogene} dataset was obtained with the accession GSE37752.
All libraries were processed as described in Chapter~\ref{chap:prep}.
For some datasets, multiple technical replicates are available for each library.
These were merged together prior to read pair counting.

\section{Session information}
<<>>=
sessionInfo()
@

\section{References}
\bibliography{refhic}
\bibliographystyle{plainnat}

\end{document}
